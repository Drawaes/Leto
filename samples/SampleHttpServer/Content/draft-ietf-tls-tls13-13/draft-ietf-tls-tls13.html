<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Major Differences from TLS 1.2"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Goals"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Goals of This Document"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Presentation Language"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Basic Block Size"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Miscellaneous"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Vectors"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Numbers"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Enumerateds"/>
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Constructed Types"/>
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Variants"/>
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Constants"/>
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Cryptographic Attributes"/>
<link href="#rfc.section.4.8.1" rel="Chapter" title="4.8.1 Digital Signing"/>
<link href="#rfc.section.4.8.2" rel="Chapter" title="4.8.2 Authenticated Encryption with Additional Data (AEAD)"/>
<link href="#rfc.section.5" rel="Chapter" title="5 The TLS Record Protocol"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Connection States"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Record Layer"/>
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Fragmentation"/>
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Record Payload Protection"/>
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Record Padding"/>
<link href="#rfc.section.6" rel="Chapter" title="6 The TLS Handshaking Protocols"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Alert Protocol"/>
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Closure Alerts"/>
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Error Alerts"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Handshake Protocol Overview"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Incorrect DHE Share"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Resumption and Pre-Shared Key (PSK)"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 Zero-RTT Data"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Handshake Protocol"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 Key Exchange Messages"/>
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 Hello Extensions"/>
<link href="#rfc.section.6.3.3" rel="Chapter" title="6.3.3 Server Parameters"/>
<link href="#rfc.section.6.3.4" rel="Chapter" title="6.3.4 Authentication Messages"/>
<link href="#rfc.section.6.3.5" rel="Chapter" title="6.3.5 Post-Handshake Messages"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Cryptographic Computations"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Key Schedule"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Updating Traffic Keys and IVs"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Traffic Key Calculation"/>
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Diffie-Hellman"/>
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Elliptic Curve Diffie-Hellman"/>
<link href="#rfc.section.7.3.3" rel="Chapter" title="7.3.3 Exporters"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Mandatory Algorithms"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 MTI Cipher Suites"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 MTI Extensions"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Application Data Protocol"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations"/>
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="12 References"/>
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Protocol Data Structures and Constant Values"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Record Layer"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Alert Messages"/>
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Handshake Protocol"/>
<link href="#rfc.appendix.A.3.1" rel="Chapter" title="A.3.1 Key Exchange Messages"/>
<link href="#rfc.appendix.A.3.2" rel="Chapter" title="A.3.2 Server Parameters Messages"/>
<link href="#rfc.appendix.A.3.3" rel="Chapter" title="A.3.3 Authentication Messages"/>
<link href="#rfc.appendix.A.3.4" rel="Chapter" title="A.3.4 Ticket Establishment"/>
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 Cipher Suites"/>
<link href="#rfc.appendix.A.4.1" rel="Chapter" title="A.4.1 Unauthenticated Operation"/>
<link href="#rfc.appendix.A.5" rel="Chapter" title="A.5 The Security Parameters"/>
<link href="#rfc.appendix.A.6" rel="Chapter" title="A.6 Changes to RFC 4492"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Implementation Notes"/>
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Random Number Generation and Seeding"/>
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Certificates and Authentication"/>
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Cipher Suite Support"/>
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Implementation Pitfalls"/>
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 Client Tracking Prevention"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Backward Compatibility"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Negotiating with an older server"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Negotiating with an older client"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Zero-RTT backwards compatibility"/>
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Backwards Compatibility Security Restrictions"/>
<link href="#rfc.appendix.D" rel="Chapter" title="D Security Analysis"/>
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Handshake Protocol"/>
<link href="#rfc.appendix.D.1.1" rel="Chapter" title="D.1.1 Authentication and Key Exchange"/>
<link href="#rfc.appendix.D.1.2" rel="Chapter" title="D.1.2 Version Rollback Attacks"/>
<link href="#rfc.appendix.D.1.3" rel="Chapter" title="D.1.3 Detecting Attacks Against the Handshake Protocol"/>
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Protecting Application Data"/>
<link href="#rfc.appendix.D.3" rel="Chapter" title="D.3 Denial of Service"/>
<link href="#rfc.appendix.D.4" rel="Chapter" title="D.4 Final Notes"/>
<link href="#rfc.appendix.E" rel="Chapter" title="E Working Group Information"/>
<link href="#rfc.appendix.F" rel="Chapter" title="F Contributors"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Rescorla, E." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-tls-tls13-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-5-25" />
  <meta name="dct.abstract" content="This document specifies Version 1.3 of the Transport Layer Security (TLS) protocol.  The TLS protocol allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery." />
  <meta name="description" content="This document specifies Version 1.3 of the Transport Layer Security (TLS) protocol.  The TLS protocol allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">E. Rescorla</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">RTFM, Inc.</td>
</tr>
<tr>
  <td class="left">Obsoletes: 5077, 5246, 5746 (if</td>
  <td class="right">May 25, 2016</td>
</tr>
<tr>
  <td class="left">           approved)</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Updates: 4492, 6066, 6961 (if approved)</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Expires: November 26, 2016</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Transport Layer Security (TLS) Protocol Version 1.3<br />
  <span class="filename">draft-ietf-tls-tls13-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies Version 1.3 of the Transport Layer Security (TLS) protocol.  The TLS protocol allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 26, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Major Differences from TLS 1.2</a></li>
</ul><li>2.   <a href="#rfc.section.2">Goals</a></li>
<li>3.   <a href="#rfc.section.3">Goals of This Document</a></li>
<li>4.   <a href="#rfc.section.4">Presentation Language</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Basic Block Size</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Miscellaneous</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Vectors</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Numbers</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Enumerateds</a></li>
<li>4.6.   <a href="#rfc.section.4.6">Constructed Types</a></li>
<ul><li>4.6.1.   <a href="#rfc.section.4.6.1">Variants</a></li>
</ul><li>4.7.   <a href="#rfc.section.4.7">Constants</a></li>
<li>4.8.   <a href="#rfc.section.4.8">Cryptographic Attributes</a></li>
<ul><li>4.8.1.   <a href="#rfc.section.4.8.1">Digital Signing</a></li>
<li>4.8.2.   <a href="#rfc.section.4.8.2">Authenticated Encryption with Additional Data (AEAD)</a></li>
</ul></ul><li>5.   <a href="#rfc.section.5">The TLS Record Protocol</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Connection States</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Record Layer</a></li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Fragmentation</a></li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Record Payload Protection</a></li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Record Padding</a></li>
</ul></ul><li>6.   <a href="#rfc.section.6">The TLS Handshaking Protocols</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Alert Protocol</a></li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Closure Alerts</a></li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Error Alerts</a></li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Handshake Protocol Overview</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Incorrect DHE Share</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">Resumption and Pre-Shared Key (PSK)</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">Zero-RTT Data</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Handshake Protocol</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">Key Exchange Messages</a></li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">Hello Extensions</a></li>
<li>6.3.3.   <a href="#rfc.section.6.3.3">Server Parameters</a></li>
<li>6.3.4.   <a href="#rfc.section.6.3.4">Authentication Messages</a></li>
<li>6.3.5.   <a href="#rfc.section.6.3.5">Post-Handshake Messages</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Cryptographic Computations</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Key Schedule</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Updating Traffic Keys and IVs</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Traffic Key Calculation</a></li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Diffie-Hellman</a></li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Elliptic Curve Diffie-Hellman</a></li>
<li>7.3.3.   <a href="#rfc.section.7.3.3">Exporters</a></li>
</ul></ul><li>8.   <a href="#rfc.section.8">Mandatory Algorithms</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">MTI Cipher Suites</a></li>
<li>8.2.   <a href="#rfc.section.8.2">MTI Extensions</a></li>
</ul><li>9.   <a href="#rfc.section.9">Application Data Protocol</a></li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a></li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a></li>
<li>12.   <a href="#rfc.references">References</a></li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Protocol Data Structures and Constant Values</a></li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Record Layer</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">Alert Messages</a></li>
<li>A.3.   <a href="#rfc.appendix.A.3">Handshake Protocol</a></li>
<ul><li>A.3.1.   <a href="#rfc.appendix.A.3.1">Key Exchange Messages</a></li>
<li>A.3.2.   <a href="#rfc.appendix.A.3.2">Server Parameters Messages</a></li>
<li>A.3.3.   <a href="#rfc.appendix.A.3.3">Authentication Messages</a></li>
<li>A.3.4.   <a href="#rfc.appendix.A.3.4">Ticket Establishment</a></li>
</ul><li>A.4.   <a href="#rfc.appendix.A.4">Cipher Suites</a></li>
<ul><li>A.4.1.   <a href="#rfc.appendix.A.4.1">Unauthenticated Operation</a></li>
</ul><li>A.5.   <a href="#rfc.appendix.A.5">The Security Parameters</a></li>
<li>A.6.   <a href="#rfc.appendix.A.6">Changes to RFC 4492</a></li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Implementation Notes</a></li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Random Number Generation and Seeding</a></li>
<li>B.2.   <a href="#rfc.appendix.B.2">Certificates and Authentication</a></li>
<li>B.3.   <a href="#rfc.appendix.B.3">Cipher Suite Support</a></li>
<li>B.4.   <a href="#rfc.appendix.B.4">Implementation Pitfalls</a></li>
<li>B.5.   <a href="#rfc.appendix.B.5">Client Tracking Prevention</a></li>
</ul><li>Appendix C.   <a href="#rfc.appendix.C">Backward Compatibility</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Negotiating with an older server</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Negotiating with an older client</a></li>
<li>C.3.   <a href="#rfc.appendix.C.3">Zero-RTT backwards compatibility</a></li>
<li>C.4.   <a href="#rfc.appendix.C.4">Backwards Compatibility Security Restrictions</a></li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">Security Analysis</a></li>
<ul><li>D.1.   <a href="#rfc.appendix.D.1">Handshake Protocol</a></li>
<ul><li>D.1.1.   <a href="#rfc.appendix.D.1.1">Authentication and Key Exchange</a></li>
<li>D.1.2.   <a href="#rfc.appendix.D.1.2">Version Rollback Attacks</a></li>
<li>D.1.3.   <a href="#rfc.appendix.D.1.3">Detecting Attacks Against the Handshake Protocol</a></li>
</ul><li>D.2.   <a href="#rfc.appendix.D.2">Protecting Application Data</a></li>
<li>D.3.   <a href="#rfc.appendix.D.3">Denial of Service</a></li>
<li>D.4.   <a href="#rfc.appendix.D.4">Final Notes</a></li>
</ul><li>Appendix E.   <a href="#rfc.appendix.E">Working Group Information</a></li>
<li>Appendix F.   <a href="#rfc.appendix.F">Contributors</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">DISCLAIMER: This is a WIP draft of TLS 1.3 and has not yet seen significant security analysis.</p>
<p id="rfc.section.1.p.2">RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH The source for this draft is maintained in GitHub. Suggested changes should be submitted as pull requests at https://github.com/tlswg/tls13-spec. Instructions are on that page as well. Editorial changes can be managed in GitHub, but any substantive change should be discussed on the TLS mailing list.</p>
<p id="rfc.section.1.p.3">The primary goal of the TLS protocol is to provide privacy and data integrity between two communicating peers. The TLS protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP <a href="#RFC0793">[RFC0793]</a>), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:</p>
<p/>

<ul>
  <li>The connection is private.  Symmetric cryptography is used for data encryption (e.g., AES <a href="#AES">[AES]</a>).  The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another the TLS Handshake Protocol.</li>
  <li>The connection is reliable.  Messages include an authentication tag which protects them against modification.</li>
</ul>
<p id="rfc.section.1.p.5">Note: The TLS Record Protocol can operate in an insecure mode but is generally only used in this mode while another protocol is using the TLS Record Protocol as a transport for negotiating security parameters.</p>
<p id="rfc.section.1.p.6">The TLS Record Protocol is used for encapsulation of various higher-level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:</p>
<p/>

<ul>
  <li>The peer&#8217;s identity can be authenticated using asymmetric (public key) cryptography (e.g., RSA <a href="#RSA">[RSA]</a>, ECDSA <a href="#ECDSA">[ECDSA]</a>) or a pre-shared symmetric key. The TLS server is always authenticated; client authentication is optional.</li>
  <li>The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.</li>
  <li>The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.</li>
</ul>
<p id="rfc.section.1.p.8">One advantage of TLS is that it is application protocol independent.  Higher-level protocols can layer on top of the TLS protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.</p>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h2>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following terms are used:</p>
<p id="rfc.section.1.1.p.3">client: The endpoint initiating the TLS connection.</p>
<p id="rfc.section.1.1.p.4">connection: A transport-layer connection between two endpoints.</p>
<p id="rfc.section.1.1.p.5">endpoint: Either the client or server of the connection.</p>
<p id="rfc.section.1.1.p.6">handshake: An initial negotiation between client and server that establishes the parameters of their transactions.</p>
<p id="rfc.section.1.1.p.7">peer: An endpoint. When discussing a particular endpoint, &#8220;peer&#8221; refers to the endpoint that is remote to the primary subject of discussion.</p>
<p id="rfc.section.1.1.p.8">receiver: An endpoint that is receiving records.</p>
<p id="rfc.section.1.1.p.9">sender: An endpoint that is transmitting records.</p>
<p id="rfc.section.1.1.p.10">session: An association between a client and a server resulting from a handshake.</p>
<p id="rfc.section.1.1.p.11">server: The endpoint which did not initiate the TLS connection.</p>
<h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#major-differences-from-tls-12" id="major-differences-from-tls-12">Major Differences from TLS 1.2</a></h2>
<p id="rfc.section.1.2.p.1">draft-13</p>
<p/>

<ul>
  <li>Allow server to send SupportedGroups.</li>
  <li>Remove 0-RTT client authentication</li>
  <li>Remove (EC)DHE 0-RTT.</li>
  <li>Flesh out 0-RTT PSK mode and shrink EarlyDataIndiation</li>
  <li>Turn PSK-resumption response into an index to save room</li>
  <li>Move CertificateStatus to an extension</li>
  <li>Extra fields in NewSessionTicket.</li>
  <li>Restructure key schedule and add a resumption_context value.</li>
  <li>Require DH public keys and secrets to be zero-padded to the size of the group.</li>
  <li>Remove the redundant length fields in KeyShareEntry.</li>
</ul>
<p id="rfc.section.1.2.p.3">draft-12</p>
<p/>

<ul>
  <li>Provide a list of the PSK cipher suites.</li>
  <li>Remove the ability for the ServerHello to have no extensions (this aligns the syntax with the text).</li>
  <li>Clarify that the server can send application data after its first flight (0.5 RTT data)</li>
  <li>Revise signature algorithm negotiation to group hash, signature algorithm, and curve together. This is backwards compatible.</li>
  <li>Make ticket lifetime mandatory and limit it to a week.</li>
  <li>Make the purpose strings lower-case. This matches how people are implementing for interop.</li>
  <li>Define exporters.</li>
  <li>Editorial cleanup</li>
</ul>
<p id="rfc.section.1.2.p.5">draft-11</p>
<p/>

<ul>
  <li>Port the CFRG curves &amp; signatures work from RFC4492bis.</li>
  <li>Remove sequence number and version from additional_data, which is now empty.</li>
  <li>Reorder values in HkdfLabel.</li>
  <li>Add support for version anti-downgrade mechanism.</li>
  <li>Update IANA considerations section and relax some of the policies.</li>
  <li>Unify authentication modes. Add post-handshake client authentication.</li>
  <li>Remove early_handshake content type. Terminate 0-RTT data with an alert.</li>
  <li>Reset sequence number upon key change (as proposed by Fournet et al.)</li>
</ul>
<p id="rfc.section.1.2.p.7">draft-10</p>
<p/>

<ul>
  <li>Remove ClientCertificateTypes field from CertificateRequest and add extensions.</li>
  <li>Merge client and server key shares into a single extension.</li>
</ul>
<p id="rfc.section.1.2.p.9">draft-09</p>
<p/>

<ul>
  <li>Change to RSA-PSS signatures for handshake messages.</li>
  <li>Remove support for DSA.</li>
  <li>Update key schedule per suggestions by Hugo, Hoeteck, and Bjoern Tackmann.</li>
  <li>Add support for per-record padding.</li>
  <li>Switch to encrypted record ContentType.</li>
  <li>Change HKDF labeling to include protocol version and value lengths.</li>
  <li>Shift the final decision to abort a handshake due to incompatible certificates to the client rather than having servers abort early.</li>
  <li>Deprecate SHA-1 with signatures.</li>
  <li>Add MTI algorithms.</li>
</ul>
<p id="rfc.section.1.2.p.11">draft-08</p>
<p/>

<ul>
  <li>Remove support for weak and lesser used named curves.</li>
  <li>Remove support for MD5 and SHA-224 hashes with signatures.</li>
  <li>Update lists of available AEAD cipher suites and error alerts.</li>
  <li>Reduce maximum permitted record expansion for AEAD from 2048 to 256 octets.</li>
  <li>Require digital signatures even when a previous configuration is used.</li>
  <li>Merge EarlyDataIndication and KnownConfiguration.</li>
  <li>Change code point for server_configuration to avoid collision with server_hello_done.</li>
  <li>Relax certificate_list ordering requirement to match current practice.</li>
</ul>
<p id="rfc.section.1.2.p.13">draft-07</p>
<p/>

<ul>
  <li>Integration of semi-ephemeral DH proposal.</li>
  <li>Add initial 0-RTT support.</li>
  <li>Remove resumption and replace with PSK + tickets.</li>
  <li>Move ClientKeyShare into an extension.</li>
  <li>Move to HKDF.</li>
</ul>
<p id="rfc.section.1.2.p.15">draft-06</p>
<p/>

<ul>
  <li>Prohibit RC4 negotiation for backwards compatibility.</li>
  <li>Freeze &amp; deprecate record layer version field.</li>
  <li>Update format of signatures with context.</li>
  <li>Remove explicit IV.</li>
</ul>
<p id="rfc.section.1.2.p.17">draft-05</p>
<p/>

<ul>
  <li>Prohibit SSL negotiation for backwards compatibility.</li>
  <li>Fix which MS is used for exporters.</li>
</ul>
<p id="rfc.section.1.2.p.19">draft-04</p>
<p/>

<ul>
  <li>Modify key computations to include session hash.</li>
  <li>Remove ChangeCipherSpec.</li>
  <li>Renumber the new handshake messages to be somewhat more consistent with existing convention and to remove a duplicate registration.</li>
  <li>Remove renegotiation.</li>
  <li>Remove point format negotiation.</li>
</ul>
<p id="rfc.section.1.2.p.21">draft-03</p>
<p/>

<ul>
  <li>Remove GMT time.</li>
  <li>Merge in support for ECC from RFC 4492 but without explicit curves.</li>
  <li>Remove the unnecessary length field from the AD input to AEAD ciphers.</li>
  <li>Rename {Client,Server}KeyExchange to {Client,Server}KeyShare.</li>
  <li>Add an explicit HelloRetryRequest to reject the client&#8217;s.</li>
</ul>
<p id="rfc.section.1.2.p.23">draft-02</p>
<p/>

<ul>
  <li>Increment version number.</li>
  <li>Rework handshake to provide 1-RTT mode.</li>
  <li>Remove custom DHE groups.</li>
  <li>Remove support for compression.</li>
  <li>Remove support for static RSA and DH key exchange.</li>
  <li>Remove support for non-AEAD ciphers.</li>
</ul>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#goals" id="goals">Goals</a></h1>
<p id="rfc.section.2.p.1">The goals of the TLS protocol, in order of priority, are as follows:</p>
<p/>

<ol>
  <li>Cryptographic security: TLS should be used to establish a secure connection between two parties.</li>
  <li>Interoperability: Independent programmers should be able to develop applications utilizing TLS that can successfully exchange cryptographic parameters without knowledge of one another&#8217;s code.</li>
  <li>Extensibility: TLS seeks to provide a framework into which new public key and record protection methods can be incorporated as necessary. This will also accomplish two sub-goals: preventing the need to create a new protocol (and risking the introduction of possible new weaknesses) and avoiding the need to implement an entire new security library.</li>
  <li>Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.</li>
</ol>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#goals-of-this-document" id="goals-of-this-document">Goals of This Document</a></h1>
<p id="rfc.section.3.p.1">This document and the TLS protocol itself have evolved from the SSL 3.0 Protocol Specification as published by Netscape. The differences between this version and previous versions are significant enough that the various versions of TLS and SSL 3.0 do not interoperate (although each protocol incorporates a mechanism by which an implementation can back down to prior versions). This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.</p>
<p id="rfc.section.3.p.2">This document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#presentation-language" id="presentation-language">Presentation Language</a></h1>
<p id="rfc.section.4.p.1">This document deals with the formatting of data in an external representation.  The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language &#8220;C&#8221; in its syntax and XDR <a href="#RFC4506">[RFC4506]</a> in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only; it has no general application beyond that particular goal.</p>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#basic-block-size" id="basic-block-size">Basic Block Size</a></h2>
<p id="rfc.section.4.1.p.1">The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the byte stream, a multi-byte item (a numeric in the example) is formed (using C notation) by:</p>
<pre>
   value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
           ... | byte[n-1];
</pre>
<p id="rfc.section.4.1.p.2">This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.</p>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h2>
<p id="rfc.section.4.2.p.1">Comments begin with &#8220;/*&#8221; and end with &#8220;*/&#8221;.</p>
<p id="rfc.section.4.2.p.2">Optional components are denoted by enclosing them in &#8220;[[ ]]&#8221; double brackets.</p>
<p id="rfc.section.4.2.p.3">Single-byte entities containing uninterpreted data are of type opaque.</p>
<h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#vectors" id="vectors">Vectors</a></h2>
<p id="rfc.section.4.3.p.1">A vector (single-dimensioned array) is a stream of homogeneous data elements.  The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T&#8217;, that is a fixed- length vector of type T is</p>
<pre>
   T T'[n];
</pre>
<p id="rfc.section.4.3.p.2">Here, T&#8217; occupies n bytes in the data stream, where n is a multiple of the size of T.  The length of the vector is not included in the encoded stream.</p>
<p id="rfc.section.4.3.p.3">In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.</p>
<pre>
   opaque Datum[3];      /* three uninterpreted bytes */
   Datum Data[9];        /* 3 consecutive 3 byte vectors */
</pre>
<p id="rfc.section.4.3.p.4">Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When these are encoded, the actual length precedes the vector&#8217;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#8217;s specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.</p>
<pre>
   T T'&lt;floor..ceiling&gt;;
</pre>
<p id="rfc.section.4.3.p.5">In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, which is sufficient to represent the value 400 (see <a href="#numbers">Section 4.4</a>). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17-byte vector of uint16 would be illegal).</p>
<pre>
   opaque mandatory&lt;300..400&gt;;
         /* length field is 2 bytes, cannot be empty */
   uint16 longer&lt;0..800&gt;;
         /* zero to 400 16-bit unsigned integers */
</pre>
<h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#numbers" id="numbers">Numbers</a></h2>
<p id="rfc.section.4.4.p.1">The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated as described in <a href="#basic-block-size">Section 4.1</a> and are also unsigned. The following numeric types are predefined.</p>
<pre>
   uint8 uint16[2];
   uint8 uint24[3];
   uint8 uint32[4];
   uint8 uint64[8];
</pre>
<p id="rfc.section.4.4.p.2">All values, here and elsewhere in the specification, are stored in network byte (big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.</p>
<p id="rfc.section.4.4.p.3">Note that in some cases (e.g., DH parameters) it is necessary to represent integers as opaque vectors. In such cases, they are represented as unsigned integers (i.e., additional leading zero octets are not used even if the most significant bit is set).</p>
<h2 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#enumerateds" id="enumerateds">Enumerateds</a></h2>
<p id="rfc.section.4.5.p.1">An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared.  Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.</p>
<pre>
   enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
</pre>
<p id="rfc.section.4.5.p.2">An enumerated occupies as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.</p>
<pre>
   enum { red(3), blue(5), white(7) } Color;
</pre>
<p id="rfc.section.4.5.p.3">One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element.</p>
<p id="rfc.section.4.5.p.4">In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4.</p>
<pre>
   enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
</pre>
<p id="rfc.section.4.5.p.5">The names of the elements of an enumeration are scoped within the defined type.  In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.</p>
<pre>
   Color color = Color.blue;     /* overspecified, legal */
   Color color = blue;           /* correct, type implicit */
</pre>
<p id="rfc.section.4.5.p.6">For enumerateds that are never converted to external representation, the numerical information may be omitted.</p>
<pre>
   enum { low, medium, high } Amount;
</pre>
<h2 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a> <a href="#constructed-types" id="constructed-types">Constructed Types</a></h2>
<p id="rfc.section.4.6.p.1">Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.</p>
<pre>
   struct {
       T1 f1;
       T2 f2;
       ...
       Tn fn;
   } [[T]];
</pre>
<p id="rfc.section.4.6.p.2">The fields within a structure may be qualified using the type&#8217;s name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.</p>
<h3 id="rfc.section.4.6.1"><a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#variants" id="variants">Variants</a></h3>
<p id="rfc.section.4.6.1.p.1">Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. Case arms have limited fall-through: if two case arms follow in immediate succession with no fields in between, then they both contain the same fields. Thus, in the example below, &#8220;orange&#8221; and &#8220;banana&#8221; both contain V2. Note that this is a new piece of syntax in TLS 1.2.</p>
<p id="rfc.section.4.6.1.p.2">The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.</p>
<pre>
   struct {
       T1 f1;
       T2 f2;
       ....
       Tn fn;
        select (E) {
            case e1: Te1;
            case e2: Te2;
            case e3: case e4: Te3;
            ....
            case en: Ten;
        } [[fv]];
   } [[Tv]];
</pre>
<p id="rfc.section.4.6.1.p.3">For example:</p>
<pre>
   enum { apple, orange, banana } VariantTag;

   struct {
       uint16 number;
       opaque string&lt;0..10&gt;; /* variable length */
   } V1;

   struct {
       uint32 number;
       opaque string[10];    /* fixed length */
   } V2;

   struct {
       select (VariantTag) { /* value of selector is implicit */
           case apple:
             V1;   /* VariantBody, tag = apple */
           case orange:
           case banana:
             V2;   /* VariantBody, tag = orange or banana */
       } variant_body;       /* optional label on variant */
   } VariantRecord;
</pre>
<h2 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a> <a href="#constants" id="constants">Constants</a></h2>
<p id="rfc.section.4.7.p.1">Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it.</p>
<p id="rfc.section.4.7.p.2">Under-specified types (opaque, variable-length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.</p>
<p id="rfc.section.4.7.p.3">For example:</p>
<pre>
   struct {
       uint8 f1;
       uint8 f2;
   } Example1;

   Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
</pre>
<h2 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a> <a href="#cryptographic-attributes" id="cryptographic-attributes">Cryptographic Attributes</a></h2>
<p id="rfc.section.4.8.p.1">The two cryptographic operations &#8212; digital signing, and authenticated encryption with additional data (AEAD) &#8212; are designated digitally-signed, and aead-ciphered, respectively. A field&#8217;s cryptographic processing is specified by prepending an appropriate key word designation before the field&#8217;s type specification.  Cryptographic keys are implied by the current session state (see <a href="#connection-states">Section 5.1</a>).</p>
<h3 id="rfc.section.4.8.1"><a href="#rfc.section.4.8.1">4.8.1.</a> <a href="#digital-signing" id="digital-signing">Digital Signing</a></h3>
<p id="rfc.section.4.8.1.p.1">A digitally-signed element is encoded as a struct DigitallySigned:</p>
<pre>
   struct {
      SignatureScheme algorithm;
      opaque signature&lt;0..2^16-1&gt;;
   } DigitallySigned;
</pre>
<p id="rfc.section.4.8.1.p.2">The algorithm field specifies the algorithm used (see <a href="#signature-algorithms">Section 6.3.2.2</a> for the definition of this field). The signature is a digital signature using those algorithms over the contents of the element. The contents themselves do not appear on the wire but are simply calculated. The length of the signature is specified by the signing algorithm and key.</p>
<p id="rfc.section.4.8.1.p.3">In previous versions of TLS, the ServerKeyExchange format meant that attackers can obtain a signature of a message with a chosen, 32-byte prefix. Because TLS 1.3 servers are likely to also implement prior versions, the contents of the element always start with 64 bytes of octet 32 in order to clear that chosen-prefix.</p>
<p id="rfc.section.4.8.1.p.4">Following that padding is a context string used to disambiguate signatures for different purposes. The context string will be specified whenever a digitally-signed element is used. A single 0 byte is appended to the context to act as a separator.</p>
<p id="rfc.section.4.8.1.p.5">Finally, the specified contents of the digitally-signed structure follow the 0 byte after the context string. (See the example at the end of this section.)</p>
<p id="rfc.section.4.8.1.p.6">The combined input is then fed into the corresponding signature algorithm to produce the signature value on the wire. See <a href="#signature-algorithms">Section 6.3.2.2</a> for algorithms defined in this specification.</p>
<p id="rfc.section.4.8.1.p.7">In the following example</p>
<pre>
   struct {
       uint8 field1;
       uint8 field2;
       digitally-signed opaque {
         uint8 field3&lt;0..255&gt;;
         uint8 field4;
       };
   } UserType;
</pre>
<p id="rfc.section.4.8.1.p.8">Assume that the context string for the signature was specified as &#8220;Example&#8221;.  The input for the signature/hash algorithm would be:</p>
<pre>
   2020202020202020202020202020202020202020202020202020202020202020
   2020202020202020202020202020202020202020202020202020202020202020
   4578616d706c6500
</pre>
<p id="rfc.section.4.8.1.p.9">followed by the encoding of the inner struct (field3 and field4).</p>
<p id="rfc.section.4.8.1.p.10">The length of the structure, in bytes, would be equal to two bytes for field1 and field2, plus two bytes for the signature algorithm, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. The length of the signature is known because the algorithm and key used for the signing are known prior to encoding or decoding this structure.</p>
<h3 id="rfc.section.4.8.2"><a href="#rfc.section.4.8.2">4.8.2.</a> <a href="#authenticated-encryption-with-additional-data-aead" id="authenticated-encryption-with-additional-data-aead">Authenticated Encryption with Additional Data (AEAD)</a></h3>
<p id="rfc.section.4.8.2.p.1">In AEAD encryption, the plaintext is simultaneously encrypted and integrity protected. The input may be of any length, and aead-ciphered output is generally larger than the input in order to accommodate the integrity check value.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#the-tls-record-protocol" id="the-tls-record-protocol">The TLS Record Protocol</a></h1>
<p id="rfc.section.5.p.1">The TLS Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, protects the records, and transmits the result. Received data is decrypted and verified, reassembled, and then delivered to higher-level clients.</p>
<p id="rfc.section.5.p.2">Three protocols that use the TLS Record Protocol are described in this document: the TLS Handshake Protocol, the Alert Protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record content types can be supported by the TLS Record Protocol. New record content type values are assigned by IANA in the TLS Content Type Registry as described in <a href="#iana-considerations">Section 11</a>.</p>
<p id="rfc.section.5.p.3">Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST send an &#8220;unexpected_message&#8221; alert.</p>
<p id="rfc.section.5.p.4">Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. As a practical matter, this means that the protocol designer must be aware of what security properties TLS does and does not provide and cannot safely rely on the latter.</p>
<p id="rfc.section.5.p.5">Note in particular that the length of a record or absence of traffic itself is not protected by encryption unless the sender uses the supplied padding mechanism &#8211; see <a href="#record-padding">Section 5.2.3</a> for more details.</p>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#connection-states" id="connection-states">Connection States</a></h2>
<p id="rfc.section.5.1.p.1">[[TODO: I plan to totally rewrite or remove this. IT seems like just cruft.]]</p>
<p id="rfc.section.5.1.p.2">A TLS connection state is the operating environment of the TLS Record Protocol.  It specifies a record protection algorithm and its parameters as well as the record protection keys and IVs for the connection in both the read and the write directions. The security parameters are set by the TLS Handshake Protocol, which also determines when new cryptographic keys are installed and used for record protection.  The initial current state always specifies that records are not protected.</p>
<p id="rfc.section.5.1.p.3">The security parameters for a TLS Connection read and write state are set by providing the following values:</p>
<p/>

<dl>
  <dt>connection end</dt>
  <dd style="margin-left: 8"><br/> Whether this entity is considered the &#8220;client&#8221; or the &#8220;server&#8221; in this connection.</dd>
  <dt>Hash algorithm</dt>
  <dd style="margin-left: 8"><br/> An algorithm used to generate keys from the appropriate secret (see <a href="#key-schedule">Section 7.1</a> and <a href="#traffic-key-calculation">Section 7.3</a>).</dd>
  <dt>record protection algorithm</dt>
  <dd style="margin-left: 8"><br/> The algorithm to be used for record protection. This algorithm must be of the AEAD type and thus provides integrity and confidentiality as a single primitive. This specification includes the key size of this algorithm and of the nonce for the AEAD algorithm.</dd>
  <dt>master secret</dt>
  <dd style="margin-left: 8"><br/> A 48-byte secret shared between the two peers in the connection and used to generate keys for protecting data.</dd>
  <dt>client random</dt>
  <dd style="margin-left: 8"><br/> A 32-byte value provided by the client.</dd>
  <dt>server random</dt>
  <dd style="margin-left: 8"><br/> A 32-byte value provided by the server.</dd>
</dl>
<p id="rfc.section.5.1.p.5">These parameters are defined in the presentation language as:</p>
<pre>
   enum { server, client } ConnectionEnd;

   enum { tls_kdf_sha256, tls_kdf_sha384 } KDFAlgorithm;

   enum { aes_gcm } RecordProtAlgorithm;

   /* The algorithms specified in KDFAlgorithm and
      RecordProtAlgorithm may be added to. */

   struct {
       ConnectionEnd          entity;
       KDFAlgorithm           kdf_algorithm;
       RecordProtAlgorithm    record_prot_algorithm;
       uint8                  enc_key_length;
       uint8                  iv_length;
       opaque                 hs_master_secret[48];
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;
</pre>
<p id="rfc.section.5.1.p.6">[TODO: update this to handle new key hierarchy.]</p>
<p id="rfc.section.5.1.p.7">The connection state will use the security parameters to generate the following four items:</p>
<pre>
   client write key
   server write key
   client write iv
   server write iv
</pre>
<p id="rfc.section.5.1.p.8">The client write parameters are used by the server when receiving and processing records and vice versa. The algorithm used for generating these items from the security parameters is described in <a href="#traffic-key-calculation">Section 7.3</a>.</p>
<p id="rfc.section.5.1.p.9">Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states.  These current states MUST be updated for each record processed. Each connection state includes the following elements:</p>
<p/>

<dl>
  <dt>cipher state</dt>
  <dd style="margin-left: 8"><br/> The current state of the encryption algorithm.  This will consist of the scheduled key for that connection.</dd>
  <dt>sequence number</dt>
  <dd style="margin-left: 8"><br/> Each connection state contains a sequence number, which is maintained separately for read and write states.  The sequence number is set to zero at the beginning of a connection, and whenever the key is changed.  The sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state and record key MUST use sequence number 0.  Sequence numbers are of type uint64 and MUST NOT exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS implementation would need to wrap a sequence number, it MUST either rekey (<a href="#key-update">Section 6.3.5.3</a>) or terminate the connection.</dd>
</dl>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#record-layer" id="record-layer">Record Layer</a></h2>
<p id="rfc.section.5.2.p.1">The TLS record layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.</p>
<h3 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#fragmentation" id="fragmentation">Fragmentation</a></h3>
<p id="rfc.section.5.2.1.p.1">The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Message boundaries are not preserved in the record layer (i.e., multiple messages of the same ContentType MAY be coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).  Alert messages (<a href="#alert-protocol">Section 6.1</a>) MUST NOT be fragmented across records.</p>
<pre>
   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   enum {
       alert(21),
       handshake(22),
       application_data(23)
       (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion record_version = { 3, 1 };    /* TLS v1.x */
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;
</pre>
<p/>

<dl>
  <dt>type</dt>
  <dd style="margin-left: 8"><br/> The higher-level protocol used to process the enclosed fragment.</dd>
  <dt>record_version</dt>
  <dd style="margin-left: 8"><br/> The protocol version the current record is compatible with.  This value MUST be set to { 3, 1 } for all records.  This field is deprecated and MUST be ignored for all purposes.</dd>
  <dt>length</dt>
  <dd style="margin-left: 8"><br/> The length (in bytes) of the following TLSPlaintext.fragment.  The length MUST NOT exceed 2^14.</dd>
  <dt>fragment</dt>
  <dd style="margin-left: 8"><br/> The application data.  This data is transparent and treated as an independent block to be dealt with by the higher-level protocol specified by the type field.</dd>
</dl>
<p id="rfc.section.5.2.1.p.3">This document describes TLS Version 1.3, which uses the version { 3, 4 }.  The version value 3.4 is historical, deriving from the use of { 3, 1 } for TLS 1.0 and { 3, 0 } for SSL 3.0. In order to maximize backwards compatibility, the record layer version identifies as simply TLS 1.0.  Endpoints supporting other versions negotiate the version to use by following the procedure and requirements in <a href="#backward-compatibility">Appendix C</a>.</p>
<p id="rfc.section.5.2.1.p.4">Implementations MUST NOT send zero-length fragments of Handshake or Alert types, even if those fragments contain padding. Zero-length fragments of Application data MAY be sent as they are potentially useful as a traffic analysis countermeasure.</p>
<p id="rfc.section.5.2.1.p.5">When record protection has not yet been engaged, TLSPlaintext structures are written directly onto the wire. Once record protection has started, TLSPlaintext records are protected and sent as described in the following section.</p>
<h3 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#record-payload-protection" id="record-payload-protection">Record Payload Protection</a></h3>
<p id="rfc.section.5.2.2.p.1">The record protection functions translate a TLSPlaintext structure into a TLSCiphertext. The deprotection functions reverse the process. In TLS 1.3 as opposed to previous versions of TLS, all ciphers are modeled as &#8220;Authenticated Encryption with Additional Data&#8221; (AEAD) <a href="#RFC5116">[RFC5116]</a>.  AEAD functions provide a unified encryption and authentication operation which turns plaintext into authenticated ciphertext and back again.</p>
<p id="rfc.section.5.2.2.p.2">AEAD ciphers take as input a single key, a nonce, a plaintext, and &#8220;additional data&#8221; to be included in the authentication check, as described in Section 2.1 of <a href="#RFC5116">[RFC5116]</a>. The key is either the client_write_key or the server_write_key and in TLS 1.3 the additional data input is empty (zero length).</p>
<pre>
   struct {
       ContentType opaque_type = application_data(23); /* see fragment.type */
       ProtocolVersion record_version = { 3, 1 };    /* TLS v1.x */
       uint16 length;
       aead-ciphered struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
       } fragment;
   } TLSCiphertext;
</pre>
<p/>

<dl>
  <dt>opaque_type</dt>
  <dd style="margin-left: 8"><br/> The outer opaque_type field of a TLSCiphertext record is always set to the value 23 (application_data) for outward compatibility with middleboxes accustomed to parsing previous versions of TLS.  The actual content type of the record is found in fragment.type after decryption.</dd>
  <dt>record_version</dt>
  <dd style="margin-left: 8"><br/> The record_version field is identical to TLSPlaintext.record_version and is always { 3, 1 }.  Note that the handshake protocol including the ClientHello and ServerHello messages authenticates the protocol version, so this value is redundant.</dd>
  <dt>length</dt>
  <dd style="margin-left: 8"><br/> The length (in bytes) of the following TLSCiphertext.fragment.  The length MUST NOT exceed 2^14 + 256.  An endpoint that receives a record that exceeds this length MUST generate a fatal &#8220;record_overflow&#8221; alert.</dd>
  <dt>fragment.content</dt>
  <dd style="margin-left: 8"><br/> The cleartext of TLSPlaintext.fragment.</dd>
  <dt>fragment.type</dt>
  <dd style="margin-left: 8"><br/> The actual content type of the record.</dd>
  <dt>fragment.zeros</dt>
  <dd style="margin-left: 8"><br/> An arbitrary-length run of zero-valued bytes may appear in the cleartext after the type field.  This provides an opportunity for senders to pad any TLS record by a chosen amount as long as the total stays within record size limits.  See <a href="#record-padding">Section 5.2.3</a> for more details.</dd>
  <dt>fragment</dt>
  <dd style="margin-left: 8"><br/> The AEAD encrypted form of TLSPlaintext.fragment + TLSPlaintext.type + zeros, where &#8220;+&#8221; denotes concatenation.</dd>
</dl>
<p id="rfc.section.5.2.2.p.4">The length of the per-record nonce (iv_length) is set to max(8 bytes, N_MIN) for the AEAD algorithm (see <a href="#RFC5116">[RFC5116]</a> Section 4). An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.  The per-record nonce for the AEAD construction is formed as follows:</p>
<p/>

<ol>
  <li>The 64-bit record sequence number is padded to the left with zeroes to iv_length.</li>
  <li>The padded sequence number is XORed with the static client_write_iv or server_write_iv, depending on the role.</li>
</ol>
<p id="rfc.section.5.2.2.p.6">The resulting quantity (of length iv_length) is used as the per-record nonce.</p>
<p id="rfc.section.5.2.2.p.7">Note: This is a different construction from that in TLS 1.2, which specified a partially explicit nonce.</p>
<p id="rfc.section.5.2.2.p.8">The plaintext is the concatenation of TLSPlaintext.fragment and TLSPlaintext.type.</p>
<p id="rfc.section.5.2.2.p.9">The AEAD output consists of the ciphertext output by the AEAD encryption operation. The length of the plaintext is greater than TLSPlaintext.length due to the inclusion of TLSPlaintext.type and however much padding is supplied by the sender.  The length of aead_output will generally be larger than the plaintext, but by an amount that varies with the AEAD cipher. Since the ciphers might incorporate padding, the amount of overhead could vary with different lengths of plaintext. Symbolically,</p>
<pre>
   AEADEncrypted =
       AEAD-Encrypt(write_key, nonce, plaintext of fragment)
</pre>
<p id="rfc.section.5.2.2.p.10">In order to decrypt and verify, the cipher takes as input the key, nonce, and the AEADEncrypted value. The output is either the plaintext or an error indicating that the decryption failed. There is no separate integrity check. That is:</p>
<pre>
   plaintext of fragment =
       AEAD-Decrypt(write_key, nonce, AEADEncrypted)
</pre>
<p id="rfc.section.5.2.2.p.11">If the decryption fails, a fatal &#8220;bad_record_mac&#8221; alert MUST be generated.</p>
<p id="rfc.section.5.2.2.p.12">An AEAD cipher MUST NOT produce an expansion of greater than 255 bytes.  An endpoint that receives a record from its peer with TLSCipherText.length larger than 2^14 + 256 octets MUST generate a fatal &#8220;record_overflow&#8221; alert.  This limit is derived from the maximum TLSPlaintext length of 2^14 octets + 1 octet for ContentType + the maximum AEAD expansion of 255 octets.</p>
<h3 id="rfc.section.5.2.3"><a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#record-padding" id="record-padding">Record Padding</a></h3>
<p id="rfc.section.5.2.3.p.1">All encrypted TLS records can be padded to inflate the size of the TLSCipherText.  This allows the sender to hide the size of the traffic from an observer.</p>
<p id="rfc.section.5.2.3.p.2">When generating a TLSCiphertext record, implementations MAY choose to pad.  An unpadded record is just a record with a padding length of zero.  Padding is a string of zero-valued bytes appended to the ContentType field before encryption.  Implementations MUST set the padding octets to all zeros before encrypting.</p>
<p id="rfc.section.5.2.3.p.3">Application Data records may contain a zero-length fragment.content if the sender desires.  This permits generation of plausibly-sized cover traffic in contexts where the presence or absence of activity may be sensitive.  Implementations MUST NOT send Handshake or Alert records that have a zero-length fragment.content.</p>
<p id="rfc.section.5.2.3.p.4">The padding sent is automatically verified by the record protection mechanism: Upon successful decryption of a TLSCiphertext.fragment, the receiving implementation scans the field from the end toward the beginning until it finds a non-zero octet. This non-zero octet is the content type of the message.  This padding scheme was selected because it allows padding of any encrypted TLS record by an arbitrary size (from zero up to TLS record size limits) without introducing new content types.  The design also enforces all-zero padding octets, which allows for quick detection of padding errors.</p>
<p id="rfc.section.5.2.3.p.5">Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption.  If a receiving implementation does not find a non-zero octet in the cleartext, it should treat the record as having an unexpected ContentType, sending an &#8220;unexpected_message&#8221; alert.</p>
<p id="rfc.section.5.2.3.p.6">The presence of padding does not change the overall record size limitations &#8211; the full fragment plaintext may not exceed 2^14 octets.</p>
<p id="rfc.section.5.2.3.p.7">Selecting a padding policy that suggests when and how much to pad is a complex topic, and is beyond the scope of this specification. If the application layer protocol atop TLS permits padding, it may be preferable to pad application_data TLS records within the application layer.  Padding for encrypted handshake and alert TLS records must still be handled at the TLS layer, though.  Later documents may define padding selection algorithms, or define a padding policy request mechanism through TLS extensions or some other means.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#the-tls-handshaking-protocols" id="the-tls-handshaking-protocols">The TLS Handshaking Protocols</a></h1>
<p id="rfc.section.6.p.1">TLS has two subprotocols that are used to allow peers to agree upon security parameters for the record layer, to authenticate themselves, to instantiate negotiated security parameters, and to report error conditions to each other.</p>
<p id="rfc.section.6.p.2">The TLS Handshake Protocol is responsible for negotiating a session, which consists of the following items:</p>
<p/>

<dl>
  <dt>peer certificate</dt>
  <dd style="margin-left: 8"><br/> X509v3 <a href="#RFC5280">[RFC5280]</a> certificate of the peer.  This element of the state may be null.</dd>
  <dt>cipher spec</dt>
  <dd style="margin-left: 8"><br/> Specifies the authentication and key establishment algorithms, the hash for use with HKDF to generate keying material, and the record protection algorithm (See <a href="#the-security-parameters">Appendix A.5</a> for formal definition.)</dd>
  <dt>resumption master secret</dt>
  <dd style="margin-left: 8"><br/> a secret shared between the client and server that can be used as a pre-shared symmetric key (PSK) in future connections.</dd>
</dl>
<p id="rfc.section.6.p.4">These items are then used to create security parameters for use by the record layer when protecting application data. Many connections can be instantiated using the same session using a PSK established in an initial handshake.</p>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#alert-protocol" id="alert-protocol">Alert Protocol</a></h2>
<p id="rfc.section.6.1.p.1">One of the content types supported by the TLS record layer is the alert type.  Alert messages convey the severity of the message (warning or fatal) and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier MUST be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted as specified by the current connection state.</p>
<pre>
   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       end_of_early_data(1),
       unexpected_message(10),               /* fatal */
       bad_record_mac(20),                   /* fatal */
       record_overflow(22),                  /* fatal */
       handshake_failure(40),                /* fatal */
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),                /* fatal */
       unknown_ca(48),                       /* fatal */
       access_denied(49),                    /* fatal */
       decode_error(50),                     /* fatal */
       decrypt_error(51),                    /* fatal */
       protocol_version(70),                 /* fatal */
       insufficient_security(71),            /* fatal */
       internal_error(80),                   /* fatal */
       inappropriate_fallback(86),           /* fatal */
       user_canceled(90),
       missing_extension(109),               /* fatal */
       unsupported_extension(110),           /* fatal */
       certificate_unobtainable(111),
       unrecognized_name(112),
       bad_certificate_status_response(113), /* fatal */
       bad_certificate_hash_value(114),      /* fatal */
       unknown_psk_identity(115),
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
</pre>
<h3 id="rfc.section.6.1.1"><a href="#rfc.section.6.1.1">6.1.1.</a> <a href="#closure-alerts" id="closure-alerts">Closure Alerts</a></h3>
<p id="rfc.section.6.1.1.p.1">The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Failure to properly close a connection does not prohibit a session from being resumed.</p>
<p/>

<dl>
  <dt>close_notify</dt>
  <dd style="margin-left: 8"><br/> This alert notifies the recipient that the sender will not send any more messages on this connection. Any data received after a closure MUST be ignored.</dd>
  <dt>end_of_early_data</dt>
  <dd style="margin-left: 8"><br/> This alert is sent by the client to indicate that all 0-RTT application_data messages have been transmitted (or none will be sent at all) and that this is the end of the flight. This alert MUST be at the warning level. Servers MUST NOT send this alert and clients receiving it MUST terminate the connection with an &#8220;unexpected_message&#8221; alert.</dd>
  <dt>user_canceled</dt>
  <dd style="margin-left: 8"><br/> This alert notifies the recipient that the sender is canceling the handshake for some reason unrelated to a protocol failure. If a user cancels an operation after the handshake is complete, just closing the connection by sending a &#8220;close_notify&#8221; is more appropriate. This alert SHOULD be followed by a &#8220;close_notify&#8221;. This alert is generally a warning.</dd>
</dl>
<p id="rfc.section.6.1.1.p.3">Either party MAY initiate a close by sending a &#8220;close_notify&#8221; alert. Any data received after a closure alert is ignored. If a transport-level close is received prior to a &#8220;close_notify&#8221;, the receiver cannot know that all the data that was sent has been received.</p>
<p id="rfc.section.6.1.1.p.4">Each party MUST send a &#8220;close_notify&#8221; alert before closing the write side of the connection, unless some other fatal alert has been transmitted. The other party MUST respond with a &#8220;close_notify&#8221; alert of its own and close down the connection immediately, discarding any pending writes. The initiator of the close need not wait for the responding &#8220;close_notify&#8221; alert before closing the read side of the connection.</p>
<p id="rfc.section.6.1.1.p.5">If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding &#8220;close_notify&#8221; alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation MAY choose to close the transport without waiting for the responding &#8220;close_notify&#8221;. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.</p>
<p id="rfc.section.6.1.1.p.6">Note: It is assumed that closing a connection reliably delivers pending data before destroying the transport.</p>
<h3 id="rfc.section.6.1.2"><a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#error-alerts" id="error-alerts">Error Alerts</a></h3>
<p id="rfc.section.6.1.2.p.1">Error handling in the TLS Handshake Protocol is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties immediately close the connection. Servers and clients MUST forget any session-identifiers, keys, and secrets associated with a failed connection. Thus, any connection terminated with a fatal alert MUST NOT be resumed.</p>
<p id="rfc.section.6.1.2.p.2">Whenever an implementation encounters a condition which is defined as a fatal alert, it MUST send the appropriate alert prior to closing the connection. For all errors where an alert level is not explicitly specified, the sending party MAY determine at its discretion whether to treat this as a fatal error or not.  If the implementation chooses to send an alert but intends to close the connection immediately afterwards, it MUST send that alert at the fatal alert level.</p>
<p id="rfc.section.6.1.2.p.3">If an alert with a level of warning is sent and received, generally the connection can continue normally. If the receiving party decides not to proceed with the connection (e.g., after having received a &#8220;user_canceled&#8221; alert that it is not willing to accept), it SHOULD send a fatal alert to terminate the connection. Given this, the sending peer cannot, in general, know how the receiving party will behave. Therefore, warning alerts are not very useful when the sending party wants to continue the connection, and thus are sometimes omitted. For example, if a party decides to accept an expired certificate (perhaps after confirming this with the user) and wants to continue the connection, it would not generally send a &#8220;certificate_expired&#8221; alert.</p>
<p id="rfc.section.6.1.2.p.4">The following error alerts are defined:</p>
<p/>

<dl>
  <dt>unexpected_message</dt>
  <dd style="margin-left: 8"><br/> An inappropriate message was received.  This alert is always fatal and should never be observed in communication between proper implementations.</dd>
  <dt>bad_record_mac</dt>
  <dd style="margin-left: 8"><br/> This alert is returned if a record is received which cannot be deprotected. Because AEAD algorithms combine decryption and verification, this alert is used for all deprotection failures.  This alert is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</dd>
  <dt>record_overflow</dt>
  <dd style="margin-left: 8"><br/> A TLSCiphertext record was received that had a length more than 2^14 + 256 bytes, or a record decrypted to a TLSPlaintext record with more than 2^14 bytes.  This alert is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</dd>
  <dt>handshake_failure</dt>
  <dd style="margin-left: 8"><br/> Reception of a &#8220;handshake_failure&#8221; alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available.  This alert is always fatal.</dd>
  <dt>bad_certificate</dt>
  <dd style="margin-left: 8"><br/> A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd>
  <dt>unsupported_certificate</dt>
  <dd style="margin-left: 8"><br/> A certificate was of an unsupported type.</dd>
  <dt>certificate_revoked</dt>
  <dd style="margin-left: 8"><br/> A certificate was revoked by its signer.</dd>
  <dt>certificate_expired</dt>
  <dd style="margin-left: 8"><br/> A certificate has expired or is not currently valid.</dd>
  <dt>certificate_unknown</dt>
  <dd style="margin-left: 8"><br/> Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.</dd>
  <dt>illegal_parameter</dt>
  <dd style="margin-left: 8"><br/> A field in the handshake was out of range or inconsistent with other fields.  This alert is always fatal.</dd>
  <dt>unknown_ca</dt>
  <dd style="margin-left: 8"><br/> A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn&#8217;t be matched with a known, trusted CA.  This alert is always fatal.</dd>
  <dt>access_denied</dt>
  <dd style="margin-left: 8"><br/> A valid certificate or PSK was received, but when access control was applied, the sender decided not to proceed with negotiation.  This alert is always fatal.</dd>
  <dt>decode_error</dt>
  <dd style="margin-left: 8"><br/> A message could not be decoded because some field was out of the specified range or the length of the message was incorrect.  This alert is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</dd>
  <dt>decrypt_error</dt>
  <dd style="margin-left: 8"><br/> A handshake cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message.  This alert is always fatal.</dd>
  <dt>protocol_version</dt>
  <dd style="margin-left: 8"><br/> The protocol version the peer has attempted to negotiate is recognized but not supported.  (For example, old protocol versions might be avoided for security reasons.)  This alert is always fatal.</dd>
  <dt>insufficient_security</dt>
  <dd style="margin-left: 8"><br/> Returned instead of &#8220;handshake_failure&#8221; when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client.  This alert is always fatal.</dd>
  <dt>internal_error</dt>
  <dd style="margin-left: 8"><br/> An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue.  This alert is always fatal.</dd>
  <dt>inappropriate_fallback</dt>
  <dd style="margin-left: 8"><br/> Sent by a server in response to an invalid connection retry attempt from a client. (see [RFC7507]) This alert is always fatal.</dd>
  <dt>missing_extension</dt>
  <dd style="margin-left: 8"><br/> Sent by endpoints that receive a hello message not containing an extension that is mandatory to send for the offered TLS version.  This message is always fatal.  [[TODO: IANA Considerations.]]</dd>
  <dt>unsupported_extension</dt>
  <dd style="margin-left: 8"><br/> Sent by endpoints receiving any hello message containing an extension known to be prohibited for inclusion in the given hello message, including any extensions in a ServerHello not first offered in the corresponding ClientHello. This alert is always fatal.</dd>
  <dt>certificate_unobtainable</dt>
  <dd style="margin-left: 8"><br/> Sent by servers when unable to obtain a certificate from a URL provided by the client via the &#8220;client_certificate_url&#8221; extension <a href="#RFC6066">[RFC6066]</a>.</dd>
  <dt>unrecognized_name</dt>
  <dd style="margin-left: 8"><br/> Sent by servers when no server exists identified by the name provided by the client via the &#8220;server_name&#8221; extension <a href="#RFC6066">[RFC6066]</a>.</dd>
  <dt>bad_certificate_status_response</dt>
  <dd style="margin-left: 8"><br/> Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the &#8220;status_request&#8221; extension <a href="#RFC6066">[RFC6066]</a>. This alert is always fatal.</dd>
  <dt>bad_certificate_hash_value</dt>
  <dd style="margin-left: 8"><br/> Sent by servers when a retrieved object does not have the correct hash provided by the client via the &#8220;client_certificate_url&#8221; extension <a href="#RFC6066">[RFC6066]</a>. This alert is always fatal.</dd>
  <dt>unknown_psk_identity</dt>
  <dd style="margin-left: 8"><br/> Sent by servers when a PSK cipher suite is selected but no acceptable PSK identity is provided by the client. Sending this alert is OPTIONAL; servers MAY instead choose to send a &#8220;decrypt_error&#8221; alert to merely indicate an invalid PSK identity.</dd>
</dl>
<p id="rfc.section.6.1.2.p.6">New Alert values are assigned by IANA as described in <a href="#iana-considerations">Section 11</a>.</p>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#handshake-protocol-overview" id="handshake-protocol-overview">Handshake Protocol Overview</a></h2>
<p id="rfc.section.6.2.p.1">The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS record layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and establish shared secret keying material.</p>
<p id="rfc.section.6.2.p.2">TLS supports three basic key exchange modes:</p>
<p/>

<ul>
  <li>Diffie-Hellman (of both the finite field and elliptic curve varieties).</li>
  <li>A pre-shared symmetric key (PSK)</li>
  <li>A combination of a symmetric key and Diffie-Hellman</li>
</ul>
<p id="rfc.section.6.2.p.4">Which mode is used depends on the negotiated cipher suite. Conceptually, the handshake establishes three secrets which are used to derive all the keys.</p>
<p><a href="#tls-full">Figure 1</a> below shows the basic full TLS handshake.</p>
<div id="rfc.figure.1"/>
<div id="tls-full"/>
<pre>
       Client                                               Server

Key  ^ ClientHello
Exch | + key_share*
     v + pre_shared_key*        --------&gt;
                                                       ServerHello  ^ Key
                                                      + key_share*  | Exch
                                                 + pre_shared_key*  v
                                             {EncryptedExtensions}  ^  Server
                                             {CertificateRequest*}  v  Params
                                                    {Certificate*}  ^
                                              {CertificateVerify*}  | Auth
                                                        {Finished}  v
                                 &lt;--------     [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}                --------&gt;
       [Application Data]        &lt;-------&gt;      [Application Data]

              +  Indicates extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages that are not always sent.

              {} Indicates messages protected using keys
                 derived from handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from traffic_secret_N
</pre>
<p class="figure">Figure 1: Message flow for full TLS Handshake</p>
<p id="rfc.section.6.2.p.6">The handshake can be thought of as having three phases, indicated in the diagram above.</p>
<p id="rfc.section.6.2.p.7">Key Exchange: establish shared keying material and select the cryptographic parameters. Everything after this phase is encrypted.</p>
<p id="rfc.section.6.2.p.8">Server Parameters: establish other handshake parameters (whether the client is authenticated, application layer protocol support, etc.)</p>
<p id="rfc.section.6.2.p.9">Authentication: authenticate the server (and optionally the client) and provide key confirmation and handshake integrity.</p>
<p id="rfc.section.6.2.p.10">In the Key Exchange phase, the client sends the ClientHello (<a href="#client-hello">Section 6.3.1.1</a>) message, which contains a random nonce (ClientHello.random), its offered protocol version, cipher suite, and extensions, and in general either one or more Diffie-Hellman key shares (in the &#8220;key_share&#8221; extension <a href="#key-share">Section 6.3.2.4</a>), one or more pre-shared key labels (in the &#8220;pre_shared_key&#8221; extension <a href="#pre-shared-key-extension">Section 6.3.2.5</a>), or both.</p>
<p id="rfc.section.6.2.p.11">The server processes the ClientHello and determines the appropriate cryptographic parameters for the connection. It then responds with its own ServerHello which indicates the negotiated connection parameters. [<a href="#server-hello">Section 6.3.1.2</a>].  The combination of the ClientHello and the ServerHello determines the values of ES and SS, as described above. If either a pure (EC)DHE or (EC)DHE-PSK cipher suite is in use, then the ServerHello will contain a &#8220;key_share&#8221; extension with the server&#8217;s ephemeral Diffie-Hellman share which MUST be in the same group.  If a pure PSK or an (EC)DHE-PSK cipher suite is negotiated, then the ServerHello will contain a &#8220;pre_shared_key&#8221; extension indicating which if the client&#8217;s offered PSKs was selected.</p>
<p id="rfc.section.6.2.p.12">The server then sends two messages to establish the Server Parameters:</p>
<p/>

<dl>
  <dt>EncryptedExtensions</dt>
  <dd style="margin-left: 8">responses to any extensions which are not required in order to determine the cryptographic parameters. [<a href="#encrypted-extensions">Section 6.3.3.1</a>]</dd>
  <dt>CertificateRequest</dt>
  <dd style="margin-left: 8">if certificate-based client authentication is desired, the desired parameters for that certificate. This message will be omitted if client authentication is not desired.</dd>
</dl>
<p id="rfc.section.6.2.p.14">Finally, the client and server exchange Authentication messages. TLS uses the same set of messages every time that authentication is needed.  Specifically:</p>
<p/>

<dl>
  <dt>Certificate</dt>
  <dd style="margin-left: 8"><br/> the certificate of the endpoint. This message is omitted if the server is not authenticating with a certificate (i.e., with PSK or (EC)DHE-PSK cipher suites). Note that if raw public keys <a href="#RFC7250">[RFC7250]</a> or the cached information extension <a href="#I-D.ietf-tls-cached-info">[I-D.ietf-tls-cached-info]</a> are in use, then this message will not contain a certificate but rather some other value corresponding to the server&#8217;s long-term key.  [<a href="#certificate">Section 6.3.4.1</a>]</dd>
  <dt>CertificateVerify</dt>
  <dd style="margin-left: 8"><br/> a signature over the entire handshake using the public key in the Certificate message. This message is omitted if the server is not authenticating via a certificate (i.e., with PSK or (EC)DHE-PSK cipher suites). [<a href="#certificate-verify">Section 6.3.4.2</a>]</dd>
  <dt>Finished</dt>
  <dd style="margin-left: 8"><br/> a MAC over the entire handshake. This message provides key confirmation, binds the endpoint&#8217;s identity to the exchanged keys, and in PSK mode also authenticates the handshake. [<a href="#finished">Section 6.3.4.3</a>]</dd>
</dl>
<p id="rfc.section.6.2.p.16">Upon receiving the server&#8217;s messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify (if requested), and Finished.</p>
<p id="rfc.section.6.2.p.17">At this point, the handshake is complete, and the client and server may exchange application layer data. Application data MUST NOT be sent prior to sending the Finished message. Note that while the server may send application data prior to receiving the client&#8217;s Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.</p>
<p id="rfc.section.6.2.p.18">[[TODO: Move this elsewhere? Note that higher layers should not be overly reliant on whether TLS always negotiates the strongest possible connection between two endpoints. There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support (i.e., perform a downgrade attack). The TLS protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure in that any cipher suite offers its promised level of security: if you negotiate AES-GCM <a href="#GCM">[GCM]</a> with a 255-bit ECDHE key exchange with a host whose certificate chain you have verified, you can expect that to be reasonably &#8220;secure&#8221; against algorithmic attacks, at least in the year 2015.]]</p>
<h3 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#incorrect-dhe-share" id="incorrect-dhe-share">Incorrect DHE Share</a></h3>
<p id="rfc.section.6.2.1.p.1">If the client has not provided an appropriate &#8220;key_share&#8221; extension (e.g. it includes only DHE or ECDHE groups unacceptable or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client will need to restart the handshake with an appropriate &#8220;key_share&#8221; extension, as shown in Figure 2.  If no common cryptographic parameters can be negotiated, the server will send a &#8220;handshake_failure&#8221; or &#8220;insufficient_security&#8221; fatal alert (see <a href="#alert-protocol">Section 6.1</a>).</p>
<div id="rfc.figure.2"/>
<div id="tls-restart"/>
<pre>
         Client                                               Server

         ClientHello
           + key_share             --------&gt;
                                   &lt;--------       HelloRetryRequest

         ClientHello
           + key_share             --------&gt;
                                                         ServerHello
                                                         + key_share
                                               {EncryptedExtensions}
                                               {CertificateRequest*}
                                                      {Certificate*}
                                                {CertificateVerify*}
                                                          {Finished}
                                   &lt;--------     [Application Data*]
         {Certificate*}
         {CertificateVerify*}
         {Finished}                --------&gt;
         [Application Data]        &lt;-------&gt;     [Application Data]
</pre>
<p class="figure">Figure 2: Message flow for a full handshake with mismatched parameters</p>
<p id="rfc.section.6.2.1.p.2">Note: the handshake transcript includes the initial ClientHello/HelloRetryRequest exchange. It is not reset with the new ClientHello.</p>
<p id="rfc.section.6.2.1.p.3">TLS also allows several optimized variants of the basic handshake, as described below.</p>
<h3 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#resumption-and-psk" id="resumption-and-psk">Resumption and Pre-Shared Key (PSK)</a></h3>
<p id="rfc.section.6.2.2.p.1">Although TLS PSKs can be established out of band, PSKs can also be established in a previous session and then reused (&#8220;session resumption&#8221;). Once a handshake has completed, the server can send the client a PSK identity which corresponds to a key derived from the initial handshake (See <a href="#new-session-ticket-message">Section 6.3.5.1</a>). The client can then use that PSK identity in future handshakes to negotiate use of the PSK; if the server accepts it, then the security context of the original connection is tied to the new connection. In TLS 1.2 and below, this functionality was provided by &#8220;session resumption&#8221; and &#8220;session tickets&#8221; <a href="#RFC5077">[RFC5077]</a>. Both mechanisms are obsoleted in TLS 1.3.</p>
<p id="rfc.section.6.2.2.p.2">PSK cipher suites can either use PSK in combination with an (EC)DHE exchange in order to provide forward secrecy in combination with shared keys, or can use PSKs alone, at the cost of losing forward secrecy.</p>
<p><a href="#tls-resumption-psk">Figure 3</a> shows a pair of handshakes in which the first establishes a PSK and the second uses it:</p>
<div id="rfc.figure.3"/>
<div id="tls-resumption-psk"/>
<pre>
       Client                                               Server

Initial Handshake:
       ClientHello
        + key_share              --------&gt;
                                                       ServerHello
                                                       + key_share
                                             {EncryptedExtensions}
                                             {CertificateRequest*}
                                                    {Certificate*}
                                              {CertificateVerify*}
                                                        {Finished}
                                 &lt;--------     [Application Data*]
       {Certificate*}
       {CertificateVerify*}
       {Finished}                --------&gt;
                                 &lt;--------      [NewSessionTicket]
       [Application Data]        &lt;-------&gt;      [Application Data]


Subsequent Handshake:
       ClientHello
         + key_share
         + pre_shared_key        --------&gt;
                                                       ServerHello
                                                  + pre_shared_key
                                                      + key_share*
                                             {EncryptedExtensions}
                                                        {Finished}
                                 &lt;--------     [Application Data*]
       {Finished}                --------&gt;
       [Application Data]        &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 3: Message flow for resumption and PSK</p>
<p id="rfc.section.6.2.2.p.4">As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify. When a client offers resumption via PSK it SHOULD also supply a &#8220;key_share&#8221; extension to the server as well; this allows server to decline resumption and fall back to a full handshake.  A &#8220;key_share&#8221; extension MUST also be sent if the client is attempting to negotiate an (EC)DHE-PSK cipher suite.</p>
<h3 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#zero-rtt-data" id="zero-rtt-data">Zero-RTT Data</a></h3>
<p id="rfc.section.6.2.3.p.1">When resuming via a PSK with an appropriate ticket (i.e., one with the &#8220;allow_early_data&#8221; flag), clients can also send data on their first flight (&#8220;early data&#8221;). This data is encrypted solely under keys derived using the PSK as the static secret.  As shown in <a href="#tls-0-rtt">Figure 4</a>, the Zero-RTT data is just added to the 1-RTT handshake in the first flight, the rest of the handshake uses the same messages.</p>
<div id="rfc.figure.4"/>
<div id="tls-0-rtt"/>
<pre>
         Client                                               Server

         ClientHello
           + early_data
           + key_share*
         (EncryptedExtensions)
         (Finished)
         (Application Data*)
         (end_of_early_data)        --------&gt;
                                                         ServerHello
                                                        + early_data
                                                         + key_share
                                               {EncryptedExtensions}
                                               {CertificateRequest*}
                                                          {Finished}
                                   &lt;--------     [Application Data*]
         {Certificate*}
         {CertificateVerify*}
         {Finished}                --------&gt;

         [Application Data]        &lt;-------&gt;      [Application Data]

               *  Indicates optional or situation-dependent
                  messages that are not always sent.

               () Indicates messages protected using keys
                  derived from early_traffic_secret.

               {} Indicates messages protected using keys
                  derived from handshake_traffic_secret.

               [] Indicates messages protected using keys
                  derived from traffic_secret_N
</pre>
<p class="figure">Figure 4: Message flow for a zero round trip handshake</p>
<p id="rfc.section.6.2.3.p.2">[[OPEN ISSUE: Should it be possible to combine 0-RTT with the server authenticating via a signature https://github.com/tlswg/tls13-spec/issues/443]]</p>
<p id="rfc.section.6.2.3.p.3">IMPORTANT NOTE: The security properties for 0-RTT data (regardless of the cipher suite) are weaker than those for other kinds of TLS data.  Specifically:</p>
<p/>

<ol>
  <li>This data is not forward secret, because it is encrypted solely with the PSK.</li>
  <li>There are no guarantees of non-replay between connections.  Unless the server takes special measures outside those provided by TLS (See <a href="#replay-time">Section 6.3.2.7.2</a>), the server has no guarantee that the same 0-RTT data was not transmitted on multiple 0-RTT connections.  This is especially relevant if the data is authenticated either with TLS client authentication or inside the application layer protocol. However, 0-RTT data cannot be duplicated within a connection (i.e., the server will not process the same data twice for the same connection) and an attacker will not be able to make 0-RTT data appear to be 1-RTT data (because it is protected with different keys.)</li>
</ol>
<p id="rfc.section.6.2.3.p.5">The contents and significance of each message will be presented in detail in the following sections.</p>
<h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#handshake-protocol" id="handshake-protocol">Handshake Protocol</a></h2>
<p id="rfc.section.6.3.p.1">The TLS Handshake Protocol is one of the defined higher-level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures, which are processed and transmitted as specified by the current active session state.</p>
<pre>
   enum {
       client_hello(1),
       server_hello(2),
       session_ticket(4),
       hello_retry_request(6),
       encrypted_extensions(8),
       certificate(11),
       certificate_request(13),
       certificate_verify(15),
       finished(20),
       key_update(24),
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (HandshakeType) {
           case client_hello:          ClientHello;
           case server_hello:          ServerHello;
           case hello_retry_request:   HelloRetryRequest;
           case encrypted_extensions:  EncryptedExtensions;
           case certificate_request:   CertificateRequest;
           case certificate:           Certificate;
           case certificate_verify:    CertificateVerify;
           case finished:              Finished;
           case session_ticket:        NewSessionTicket;
           case key_update:            KeyUpdate;
       } body;
   } Handshake;
</pre>
<p id="rfc.section.6.3.p.2">The TLS Handshake Protocol messages are presented below in the order they MUST be sent; sending handshake messages in an unexpected order results in an &#8220;unexpected_message&#8221; fatal error. Unneeded handshake messages can be omitted, however.</p>
<p id="rfc.section.6.3.p.3">New handshake message types are assigned by IANA as described in <a href="#iana-considerations">Section 11</a>.</p>
<h3 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#key-exchange-messages" id="key-exchange-messages">Key Exchange Messages</a></h3>
<p id="rfc.section.6.3.1.p.1">The key exchange messages are used to exchange security capabilities between the client and server and to establish the traffic keys used to protect the handshake and the data.</p>
<h4 id="rfc.section.6.3.1.1"><a href="#rfc.section.6.3.1.1">6.3.1.1.</a> <a href="#client-hello" id="client-hello">Client Hello</a></h4>
<p id="rfc.section.6.3.1.1.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>When a client first connects to a server, it is required to send the ClientHello as its first message. The client will also send a ClientHello when the server has responded to its ClientHello with a ServerHello that selects cryptographic parameters that don&#8217;t match the client&#8217;s &#8220;key_share&#8221; extension. In that case, the client MUST send the same ClientHello (without modification) except including a new KeyShareEntry as the lowest priority share (i.e., appended to the list of shares in the &#8220;key_share&#8221; extension). If a server receives a ClientHello at any other time, it MUST send a fatal &#8220;unexpected_message&#8221; alert and close the connection.</li>
</ul>
<p id="rfc.section.6.3.1.1.p.3">Structure of this message:</p>
<p/>

<ul class="empty">
  <li>The ClientHello message includes a random structure, which is used later in the protocol.</li>
</ul>
<p id="rfc.section.6.3.1.1.p.5">The cipher suite list, passed from the client to the server in the ClientHello message, contains the combinations of cryptographic algorithms supported by the client in order of the client&#8217;s preference (favorite choice first). Each cipher suite defines a key exchange algorithm, a record protection algorithm (including secret key length) and a hash to be used with HKDF. The server will select a cipher suite or, if no acceptable choices are presented, return a &#8220;handshake_failure&#8221; alert and close the connection. If the list contains cipher suites the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites, and process the remaining ones as usual.</p>
<pre>
   struct {
       opaque random_bytes[32];
   } Random;

   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   struct {
       ProtocolVersion client_version = { 3, 4 };    /* TLS v1.3 */
       Random random;
       opaque legacy_session_id&lt;0..32&gt;;
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       opaque legacy_compression_methods&lt;1..2^8-1&gt;;
       Extension extensions&lt;0..2^16-1&gt;;
   } ClientHello;
</pre>
<p id="rfc.section.6.3.1.1.p.6">TLS allows extensions to follow the compression_methods field in an extensions block. The presence of extensions can be detected by determining whether there are bytes following the compression_methods at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.  As of TLS 1.3, all clients and servers will send at least one extension (at least &#8220;key_share&#8221; or &#8220;pre_shared_key&#8221;).</p>
<p/>

<dl>
  <dt>client_version</dt>
  <dd style="margin-left: 8"><br/> The version of the TLS protocol by which the client wishes to communicate during this session.  This SHOULD be the latest (highest valued) version supported by the client.  For this version of the specification, the version will be { 3, 4 }. (See <a href="#backward-compatibility">Appendix C</a> for details about backward compatibility.)</dd>
  <dt>random</dt>
  <dd style="margin-left: 8"><br/> 32 bytes generated by a secure random number generator.  See <a href="#implementation-notes">Appendix B</a> for additional information.</dd>
  <dt>legacy_session_id</dt>
  <dd style="margin-left: 8"><br/> Versions of TLS before TLS 1.3 supported a session resumption feature which has been merged with Pre-Shared Keys in this version (see <a href="#resumption-and-psk">Section 6.2.2</a>).  This field MUST be ignored by a server negotiating TLS 1.3 and SHOULD be set as a zero length vector (i.e., a single zero byte length field) by clients which do not have a cached session ID set by a pre-TLS 1.3 server.</dd>
  <dt>cipher_suites</dt>
  <dd style="margin-left: 8"><br/> This is a list of the cryptographic options supported by the client, with the client&#8217;s first preference first.  Values are defined in <a href="#cipher-suites">Appendix A.4</a>.</dd>
  <dt>legacy_compression_methods</dt>
  <dd style="margin-left: 8"><br/> Versions of TLS before 1.3 supported compression and the list of compression methods was supplied in this field. For any TLS 1.3 ClientHello, this vector MUST contain exactly one byte set to zero, which corresponds to the &#8220;null&#8221; compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST generate a fatal &#8220;illegal_parameter&#8221; alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and MUST follow the procedures for the appropriate prior version of TLS.</dd>
  <dt>extensions</dt>
  <dd style="margin-left: 8"><br/> Clients request extended functionality from servers by sending data in the extensions field.  The actual &#8220;Extension&#8221; format is defined in <a href="#hello-extensions">Section 6.3.2</a>.</dd>
</dl>
<p id="rfc.section.6.3.1.1.p.8">In the event that a client requests additional functionality using extensions, and this functionality is not supplied by the server, the client MAY abort the handshake. Note: TLS 1.3 ClientHello messages MUST always contain extensions, and a TLS 1.3 server MUST respond to any TLS 1.3 ClientHello without extensions with a fatal &#8220;decode_error&#8221; alert. TLS 1.3 servers may receive TLS 1.2 ClientHello messages without extensions. If negotiating TLS 1.2, a server MUST check that the amount of data in the message precisely matches one of these formats; if not, then it MUST send a fatal &#8220;decode_error&#8221; alert.</p>
<p id="rfc.section.6.3.1.1.p.9">After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message.</p>
<h4 id="rfc.section.6.3.1.2"><a href="#rfc.section.6.3.1.2">6.3.1.2.</a> <a href="#server-hello" id="server-hello">Server Hello</a></h4>
<p id="rfc.section.6.3.1.2.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The server will send this message in response to a ClientHello message when it was able to find an acceptable set of algorithms and the client&#8217;s &#8220;key_share&#8221; extension was acceptable. If the client proposed groups are not acceptable by the server, it will respond with a &#8220;handshake_failure&#8221; fatal alert.</li>
</ul>
<p id="rfc.section.6.3.1.2.p.3">Structure of this message:</p>
<pre>
   struct {
       ProtocolVersion server_version;
       Random random;
       CipherSuite cipher_suite;
       Extension extensions&lt;0..2^16-1&gt;;
   } ServerHello;
</pre>
<p id="rfc.section.6.3.1.2.p.4">In prior versions of TLS, the extensions field could be omitted entirely if not needed, similar to ClientHello.  As of TLS 1.3, all clients and servers will send at least one extension (at least &#8220;key_share&#8221; or &#8220;pre_shared_key&#8221;).</p>
<p/>

<dl>
  <dt>server_version</dt>
  <dd style="margin-left: 8"><br/> This field will contain the lower of that suggested by the client in the ClientHello and the highest supported by the server.  For this version of the specification, the version is { 3, 4 }.  (See <a href="#backward-compatibility">Appendix C</a> for details about backward compatibility.)</dd>
  <dt>random</dt>
  <dd style="margin-left: 8"><br/> This structure is generated by the server and MUST be generated independently of the ClientHello.random.</dd>
  <dt>cipher_suite</dt>
  <dd style="margin-left: 8"><br/> The single cipher suite selected by the server from the list in ClientHello.cipher_suites.  For resumed sessions, this field is the value from the state of the session being resumed.  [[TODO: interaction with PSK.]]</dd>
  <dt>extensions</dt>
  <dd style="margin-left: 8"><br/> A list of extensions.  Note that only extensions offered by the client can appear in the server&#8217;s list. In TLS 1.3 as opposed to previous versions of TLS, the server&#8217;s extensions are split between the ServerHello and the EncryptedExtensions <a href="#encrypted-extensions">Section 6.3.3.1</a> message. The ServerHello MUST only include extensions which are required to establish the cryptographic context. Currently the only such extensions are &#8220;key_share&#8221;, &#8220;pre_shared_key&#8221;, and &#8220;early_data&#8221;.  Clients MUST check the ServerHello for the presence of any forbidden extensions and if any are found MUST terminate the handshake with a &#8220;illegal_parameter&#8221; alert.</dd>
</dl>
<p id="rfc.section.6.3.1.2.p.6">TLS 1.3 server implementations which respond to a ClientHello with a client_version indicating TLS 1.2 or below MUST set the first eight bytes of their Random value to the bytes:</p>
<pre>
  44 4F 57 4E 47 52 44 01
</pre>
<p id="rfc.section.6.3.1.2.p.7">TLS 1.2 server implementations which respond to a ClientHello with a client_version indicating TLS 1.1 or below SHOULD set the first eight bytes of their Random value to the bytes:</p>
<pre>
  44 4F 57 4E 47 52 44 00
</pre>
<p id="rfc.section.6.3.1.2.p.8">TLS 1.3 clients receiving a TLS 1.2 or below ServerHello MUST check that the top eight octets are not equal to either of these values. TLS 1.2 clients SHOULD also perform this check if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with a fatal &#8220;illegal_parameter&#8221; alert. This mechanism provides limited protection against downgrade attacks over and above that provided by the Finished exchange: because the ServerKeyExchange includes a signature over both random values, it is not possible for an active attacker to modify the randoms without detection as long as ephemeral ciphers are used. It does not provide downgrade protection when static RSA is used.</p>
<p id="rfc.section.6.3.1.2.p.9">Note: This is an update to TLS 1.2 so in practice many TLS 1.2 clients and servers will not behave as specified above.</p>
<p id="rfc.section.6.3.1.2.p.10">Note: Versions of TLS prior to TLS 1.3 used the top 32 bits of the Random value to encode the time since the UNIX epoch. The sentinel value above was selected to avoid conflicting with any valid TLS 1.2 Random value and to have a low (2^{-64}) probability of colliding with randomly selected Random values.</p>
<h4 id="rfc.section.6.3.1.3"><a href="#rfc.section.6.3.1.3">6.3.1.3.</a> <a href="#hello-retry-request" id="hello-retry-request">Hello Retry Request</a></h4>
<p id="rfc.section.6.3.1.3.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>Servers send this message in response to a ClientHello message when it was able to find an acceptable set of algorithms and groups that are mutually supported, but the client&#8217;s KeyShare did not contain an acceptable offer. If it cannot find such a match, it will respond with a fatal &#8220;handshake_failure&#8221; alert.</li>
</ul>
<p id="rfc.section.6.3.1.3.p.3">Structure of this message:</p>
<pre>
   struct {
       ProtocolVersion server_version;
       CipherSuite cipher_suite;
       NamedGroup selected_group;
       Extension extensions&lt;0..2^16-1&gt;;
   } HelloRetryRequest;
</pre>
<p/>

<dl>
  <dt>selected_group</dt>
  <dd style="margin-left: 8"><br/> The mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.</dd>
</dl>
<p id="rfc.section.6.3.1.3.p.5">The server_version, cipher_suite, and extensions fields have the same meanings as their corresponding values in the ServerHello. The server SHOULD send only the extensions necessary for the client to generate a correct ClientHello pair. As with ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello.</p>
<p id="rfc.section.6.3.1.3.p.6">Upon receipt of a HelloRetryRequest, the client MUST first verify that the selected_group field corresponds to a group which was provided in the &#8220;supported_groups&#8221; extension in the original ClientHello.  It MUST then verify that the selected_group field does not correspond to a group which was provided in the &#8220;key_share&#8221; extension in the original ClientHello. If either of these checks fails, then the client MUST abort the handshake with a fatal &#8220;handshake_failure&#8221; alert. Clients SHOULD also abort with &#8220;handshake_failure&#8221; in response to any second HelloRetryRequest which was sent in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest).</p>
<p id="rfc.section.6.3.1.3.p.7">Otherwise, the client MUST send a ClientHello with an updated KeyShare extension to the server. The client MUST append a new KeyShareEntry for the group indicated in the selected_group field to the groups in its original KeyShare.</p>
<p id="rfc.section.6.3.1.3.p.8">Upon re-sending the ClientHello and receiving the server&#8217;s ServerHello/KeyShare, the client MUST verify that the selected CipherSuite and NamedGroup match that supplied in the HelloRetryRequest. If either of these values differ, the client MUST abort the connection with a fatal &#8220;handshake_failure&#8221; alert.</p>
<h3 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2.</a> <a href="#hello-extensions" id="hello-extensions">Hello Extensions</a></h3>
<p id="rfc.section.6.3.2.p.1">The extension format is:</p>
<pre>
   struct {
       ExtensionType extension_type;
       opaque extension_data&lt;0..2^16-1&gt;;
   } Extension;

   enum {
       supported_groups(10),
       signature_algorithms(13),
       key_share(40),
       pre_shared_key(41),
       early_data(42),
       ticket_age(43),
       cookie (44),
       (65535)
   } ExtensionType;
</pre>
<p id="rfc.section.6.3.2.p.2">Here:</p>
<p/>

<ul>
  <li>&#8220;extension_type&#8221; identifies the particular extension type.</li>
  <li>&#8220;extension_data&#8221; contains information specific to the particular extension type.</li>
</ul>
<p id="rfc.section.6.3.2.p.4">The initial set of extensions is defined in <a href="#RFC6066">[RFC6066]</a>.  The list of extension types is maintained by IANA as described in <a href="#iana-considerations">Section 11</a>.</p>
<p id="rfc.section.6.3.2.p.5">An extension type MUST NOT appear in the ServerHello or HelloRetryRequest unless the same extension type appeared in the corresponding ClientHello.  If a client receives an extension type in ServerHello or HelloRetryRequest that it did not request in the associated ClientHello, it MUST abort the handshake with an &#8220;unsupported_extension&#8221; fatal alert.</p>
<p id="rfc.section.6.3.2.p.6">Nonetheless, &#8220;server-oriented&#8221; extensions may be provided in the future within this framework. Such an extension (say, of type x) would require the client to first send an extension of type x in a ClientHello with empty extension_data to indicate that it supports the extension type. In this case, the client is offering the capability to understand the extension type, and the server is taking the client up on its offer.</p>
<p id="rfc.section.6.3.2.p.7">When multiple extensions of different types are present in the ClientHello or ServerHello messages, the extensions MAY appear in any order. There MUST NOT be more than one extension of the same type.</p>
<p id="rfc.section.6.3.2.p.8">Finally, note that extensions can be sent both when starting a new session and when requesting session resumption or 0-RTT mode. Indeed, a client that requests session resumption does not in general know whether the server will accept this request, and therefore it SHOULD send the same extensions as it would send if it were not attempting resumption.</p>
<p id="rfc.section.6.3.2.p.9">In general, the specification of each extension type needs to describe the effect of the extension both during full handshake and session resumption. Most current TLS extensions are relevant only when a session is initiated: when an older session is resumed, the server does not process these extensions in ClientHello, and does not include them in ServerHello. However, some extensions may specify different behavior during session resumption.  [[TODO: update this and the previous paragraph to cover PSK-based resumption.]]</p>
<p id="rfc.section.6.3.2.p.10">There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:</p>
<p/>

<ul>
  <li>Some cases where a server does not agree to an extension are error conditions, and some are simply refusals to support particular features. In general, error alerts should be used for the former, and a field in the server extension response for the latter.</li>
  <li>Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem.  Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase.  Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.</li>
  <li>It would be technically possible to use extensions to change major aspects of the design of TLS; for example, the design of cipher suite negotiation.  This is not recommended; it would be more appropriate to define a new version of TLS &#8212; particularly since the TLS handshake algorithms have specific protection against version rollback attacks based on the version number, and the possibility of version rollback should be a significant consideration in any major design change.</li>
</ul>
<h4 id="rfc.section.6.3.2.1"><a href="#rfc.section.6.3.2.1">6.3.2.1.</a> <a href="#cookie" id="cookie">Cookie</a></h4>
<pre>
   struct {
       opaque cookie&lt;0..255&gt;;
   } Cookie;
</pre>
<p id="rfc.section.6.3.2.1.p.1">Cookies serve two primary purposes:</p>
<p/>

<ul>
  <li>Allowing the server to force the client to demonstrate reachability at their apparent network address (thus providing a measure of DoS protection). This is primarily useful for non-connection-oriented transports (see <a href="#RFC6347">[RFC6347]</a> for an example of this).</li>
  <li>Allowing the server to offload state to the client, thus allowing it to send a HelloRetryRequest without storing any state. The server does this by pickling that post-ClientHello hash state into the cookie (protected with some suitable integrity algorithm).</li>
</ul>
<p id="rfc.section.6.3.2.1.p.3">When sending a HelloRetryRequest, the server MAY provide a &#8220;cookie&#8221; extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST echo the value of the extension.  Clients MUST NOT use cookies in subsequent connections.</p>
<h4 id="rfc.section.6.3.2.2"><a href="#rfc.section.6.3.2.2">6.3.2.2.</a> <a href="#signature-algorithms" id="signature-algorithms">Signature Algorithms</a></h4>
<p id="rfc.section.6.3.2.2.p.1">The client uses the &#8220;signature_algorithms&#8221; extension to indicate to the server which signature algorithms may be used in digital signatures.</p>
<p id="rfc.section.6.3.2.2.p.2">Clients which offer one or more cipher suites which use certificate authentication (i.e., any non-PSK cipher suite) MUST send the &#8220;signature_algorithms&#8221; extension.  If this extension is not provided and no alternative cipher suite is available, the server MUST close the connection with a fatal &#8220;missing_extension&#8221; alert.  (see <a href="#mti-extensions">Section 8.2</a>)</p>
<p id="rfc.section.6.3.2.2.p.3">The &#8220;extension_data&#8221; field of this extension contains a &#8220;supported_signature_algorithms&#8221; value:</p>
<pre>
   enum {
       /* RSASSA-PKCS-v1_5 algorithms */
       rsa_pkcs1_sha1 (0x0201),
       rsa_pkcs1_sha256 (0x0401),
       rsa_pkcs1_sha384 (0x0501),
       rsa_pkcs1_sha512 (0x0601),

       /* ECDSA algorithms */
       ecdsa_secp256r1_sha256 (0x0403),
       ecdsa_secp384r1_sha384 (0x0503),
       ecdsa_secp521r1_sha512 (0x0603),

       /* RSASSA-PSS algorithms */
       rsa_pss_sha256 (0x0700),
       rsa_pss_sha384 (0x0701),
       rsa_pss_sha512 (0x0702),

       /* EdDSA algorithms */
       ed25519 (0x0703),
       ed448 (0x0704),

       /* Reserved Code Points */
       private_use (0xFE00..0xFFFF),
       (0xFFFF)
   } SignatureScheme;

   SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
</pre>
<p id="rfc.section.6.3.2.2.p.4">Note: This production is named &#8220;SignatureScheme&#8221; because there is already a SignatureAlgorithm type in TLS 1.2. We use the term &#8220;signature algorithm&#8221; throughout the text.</p>
<p id="rfc.section.6.3.2.2.p.5">Each SignatureScheme value lists a single signature algorithm that the client is willing to verify. The values are indicated in descending order of preference. Note that a signature algorithm takes as input an arbitrary-length message, rather than a digest. Algorithms which traditionally act on a digest should be defined in TLS to first hash the input with a specified hash function and then proceed as usual.  The code point groups listed above have the following meanings:</p>
<p/>

<dl>
  <dt>RSASSA-PKCS-v1_5 algorithms</dt>
  <dd style="margin-left: 8"><br/> Indicates a signature algorithm using RSASSA-PKCS1-v1_5 <a href="#RFC3447">[RFC3447]</a> with the corresponding hash algorithm as defined in <a href="#SHS">[SHS]</a>. These values refer solely to signatures which appear in certificates (see <a href="#server-certificate-selection">Section 6.3.4.1.1</a>) and are not defined for use in signed TLS handshake messages (see <a href="#digital-signing">Section 4.8.1</a>).</dd>
  <dt>ECDSA algorithms</dt>
  <dd style="margin-left: 8"><br/> Indicates a signature algorithm using ECDSA <a href="#ECDSA">[ECDSA]</a>, the corresponding curve as defined in ANSI X9.62 <a href="#X962">[X962]</a> and FIPS 186-4 <a href="#DSS">[DSS]</a>, and the corresponding hash algorithm as defined in <a href="#SHS">[SHS]</a>. The signature is represented as a DER-encoded <a href="#X690">[X690]</a> ECDSA-Sig-Value structure.</dd>
  <dt>RSASSA-PSS algorithms</dt>
  <dd style="margin-left: 8"><br/> Indicates a signature algorithm using RSASSA-PSS <a href="#RFC3447">[RFC3447]</a> with MGF1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in <a href="#SHS">[SHS]</a>. When used in signed TLS handshake messages (see <a href="#digital-signing">Section 4.8.1</a>), the length of the salt MUST be equal to the length of the digest output.</dd>
  <dt>EdDSA algorithms</dt>
  <dd style="margin-left: 8"><br/> Indicates a signature algorithm using EdDSA as defined in <a href="#I-D.irtf-cfrg-eddsa">[I-D.irtf-cfrg-eddsa]</a> or its successors. Note that these correspond to the &#8220;PureEdDSA&#8221; algorithms and not the &#8220;prehash&#8221; variants.</dd>
</dl>
<p id="rfc.section.6.3.2.2.p.7">The semantics of this extension are somewhat complicated because the cipher suite adds additional constraints on signature algorithms.  <a href="#server-certificate-selection">Section 6.3.4.1.1</a> describes the appropriate rules.</p>
<p id="rfc.section.6.3.2.2.p.8">rsa_pkcs1_sha1 and dsa_sha1 SHOULD NOT be offered. Clients offering these values for backwards compatibility MUST list them as the lowest priority (listed after all other algorithms in the supported_signature_algorithms vector). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see <a href="#server-certificate-selection">Section 6.3.4.1.1</a>).</p>
<p id="rfc.section.6.3.2.2.p.9">The signatures on certificates that are self-signed or certificates that are trust anchors are not validated since they begin a certification path (see <a href="#RFC5280">[RFC5280]</a>, Section 3.2).  A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the &#8220;signature_algorithms&#8221; extension.</p>
<p id="rfc.section.6.3.2.2.p.10">Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of <a href="#RFC5246">[RFC5246]</a> when negotiating that version. In particular:</p>
<p/>

<ul>
  <li>TLS 1.2 ClientHellos may omit this extension.</li>
  <li>In TLS 1.2, the extension contained hash/signature pairs. The pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2&#8217;s encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or negotiated by any implementation. In particular, MD5 <a href="#SLOTH">[SLOTH]</a> and SHA-224 MUST NOT be used.</li>
  <li>ecdsa_secp256r1_sha256, etc., align with TLS 1.2&#8217;s ECDSA hash/signature pairs.  However, the old semantics did not constrain the signing curve.</li>
</ul>
<h4 id="rfc.section.6.3.2.3"><a href="#rfc.section.6.3.2.3">6.3.2.3.</a> <a href="#negotiated-groups" id="negotiated-groups">Negotiated Groups</a></h4>
<p id="rfc.section.6.3.2.3.p.1">When sent by the client, the &#8220;supported_groups&#8221; extension indicates the named groups which the client supports, ordered from most preferred to least preferred.</p>
<p id="rfc.section.6.3.2.3.p.2">Note: In versions of TLS prior to TLS 1.3, this extension was named &#8220;elliptic_curves&#8221; and only contained elliptic curve groups. See <a href="#RFC4492">[RFC4492]</a> and <a href="#I-D.ietf-tls-negotiated-ff-dhe">[I-D.ietf-tls-negotiated-ff-dhe]</a>. This extension was also used to negotiate ECDSA curves. Signature algorithms are now negotiated independently (see <a href="#signature-algorithms">Section 6.3.2.2</a>).</p>
<p id="rfc.section.6.3.2.3.p.3">Clients which offer one or more (EC)DHE cipher suites MUST send at least one supported NamedGroup value and servers MUST NOT negotiate any of these cipher suites unless a supported value was provided.  If this extension is not provided and no alternative cipher suite is available, the server MUST close the connection with a fatal &#8220;missing_extension&#8221; alert.  (see <a href="#mti-extensions">Section 8.2</a>) If the extension is provided, but no compatible group is offered, the server MUST NOT negotiate a cipher suite of the relevant type. For instance, if a client supplies only ECDHE groups, the server MUST NOT negotiate finite field Diffie-Hellman. If no acceptable group can be selected across all cipher suites, then the server MUST generate a fatal &#8220;handshake_failure&#8221; alert.</p>
<p id="rfc.section.6.3.2.3.p.4">The &#8220;extension_data&#8221; field of this extension contains a &#8220;NamedGroupList&#8221; value:</p>
<pre>
   enum {
       /* Elliptic Curve Groups (ECDHE) */
       secp256r1 (23), secp384r1 (24), secp521r1 (25),
       x25519 (29), x448 (30),

       /* Finite Field Groups (DHE) */
       ffdhe2048 (256), ffdhe3072 (257), ffdhe4096 (258),
       ffdhe6144 (259), ffdhe8192 (260),

       /* Reserved Code Points */
       ffdhe_private_use (0x01FC..0x01FF),
       ecdhe_private_use (0xFE00..0xFEFF),
       (0xFFFF)
   } NamedGroup;

   struct {
       NamedGroup named_group_list&lt;1..2^16-1&gt;;
   } NamedGroupList;
</pre>
<p/>

<dl>
  <dt>Elliptic Curve Groups (ECDHE)</dt>
  <dd style="margin-left: 8"><br/> Indicates support of the corresponding named curve.  Note that some curves are also recommended in ANSI X9.62 <a href="#X962">[X962]</a> and FIPS 186-4 <a href="#DSS">[DSS]</a>. Others are recommended in <a href="#RFC7748">[RFC7748]</a>.  Values 0xFE00 through 0xFEFF are reserved for private use.</dd>
  <dt>Finite Field Groups (DHE)</dt>
  <dd style="margin-left: 8"><br/> Indicates support of the corresponding finite field group, defined in <a href="#I-D.ietf-tls-negotiated-ff-dhe">[I-D.ietf-tls-negotiated-ff-dhe]</a>.  Values 0x01FC through 0x01FF are reserved for private use.</dd>
</dl>
<p id="rfc.section.6.3.2.3.p.6">Items in named_group_list are ordered according to the client&#8217;s preferences (most preferred choice first).</p>
<p id="rfc.section.6.3.2.3.p.7">As of TLS 1.3, servers are permitted to send the &#8220;supported_groups&#8221; extension to the client.  If the server has a group it prefers to the ones in the &#8220;key_share&#8221; extension but is still willing to accept the ClientHello, it SHOULD send &#8220;supported_groups&#8221; to update the client&#8217;s view of its preferences.  Clients MUST NOT act upon any information found in &#8220;supported_groups&#8221; prior to successful completion of the handshake, but MAY use the information learned from a successfully completed handshake to change what groups they offer to a server in subsequent connections.</p>
<p id="rfc.section.6.3.2.3.p.8">[[TODO: IANA Considerations.]]</p>
<h4 id="rfc.section.6.3.2.4"><a href="#rfc.section.6.3.2.4">6.3.2.4.</a> <a href="#key-share" id="key-share">Key Share</a></h4>
<p id="rfc.section.6.3.2.4.p.1">The &#8220;key_share&#8221; extension contains the endpoint&#8217;s cryptographic parameters for non-PSK key establishment methods (currently DHE or ECDHE).</p>
<p id="rfc.section.6.3.2.4.p.2">Clients which offer one or more (EC)DHE cipher suites MUST send this extension and SHOULD send at least one supported KeyShareEntry value.  Servers MUST NOT negotiate any of these cipher suites unless a supported value was provided.  If this extension is not provided in a ServerHello or ClientHello, and the peer is offering (EC)DHE cipher suites, then the endpoint MUST close the connection with a fatal &#8220;missing_extension&#8221; alert.  (see <a href="#mti-extensions">Section 8.2</a>) Clients MAY send an empty client_shares vector in order to request group selection from the server at the cost of an additional round trip.  (see <a href="#hello-retry-request">Section 6.3.1.3</a>)</p>
<pre>
   struct {
       NamedGroup group;
       opaque key_exchange&lt;1..2^16-1&gt;;
   } KeyShareEntry;
</pre>
<p/>

<dl>
  <dt>group</dt>
  <dd style="margin-left: 8"><br/> The named group for the key being exchanged.  Finite Field Diffie-Hellman <a href="#DH">[DH]</a> parameters are described in <a href="#ffdhe-param">Section 6.3.2.4.1</a>; Elliptic Curve Diffie-Hellman parameters are described in <a href="#ecdhe-param">Section 6.3.2.4.2</a>.</dd>
  <dt>key_exchange</dt>
  <dd style="margin-left: 8"><br/> Key exchange information.  The contents of this field are determined by the specified group and its corresponding definition.  Endpoints MUST NOT send empty or otherwise invalid key_exchange values for any reason.</dd>
</dl>
<p id="rfc.section.6.3.2.4.p.4">The &#8220;extension_data&#8221; field of this extension contains a &#8220;KeyShare&#8221; value:</p>
<pre>
   struct {
       select (role) {
           case client:
               KeyShareEntry client_shares&lt;0..2^16-1&gt;;

           case server:
               KeyShareEntry server_share;
       }
   } KeyShare;
</pre>
<p/>

<dl>
  <dt>client_shares</dt>
  <dd style="margin-left: 8"><br/> A list of offered KeyShareEntry values in descending order of client preference.  This vector MAY be empty if the client is requesting a HelloRetryRequest.  The ordering of values here SHOULD match that of the ordering of offered support in the &#8220;supported_groups&#8221; extension.</dd>
  <dt>server_share</dt>
  <dd style="margin-left: 8"><br/> A single KeyShareEntry value for the negotiated cipher suite.</dd>
</dl>
<p id="rfc.section.6.3.2.4.p.6">Servers offer exactly one KeyShareEntry value, which corresponds to the key exchange used for the negotiated cipher suite.</p>
<p id="rfc.section.6.3.2.4.p.7">Clients offer an arbitrary number of KeyShareEntry values, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups.  The key_exchange values for each KeyShareEntry MUST by generated independently.  Clients MUST NOT offer multiple KeyShareEntry values for the same group and servers receiving multiple KeyShareEntry values for the same group MUST abort the connection with a fatal &#8220;illegal_parameter&#8221; alert.  Clients and servers MUST NOT offer or accept any KeyShareEntry values for groups not listed in the client&#8217;s &#8220;supported_groups&#8221; extension.  Servers MUST NOT offer a KeyShareEntry value for a group not offered by the client in its corresponding KeyShare.</p>
<p id="rfc.section.6.3.2.4.p.8">If the server selects an (EC)DHE cipher suite and no mutually supported group is available between the two endpoints&#8217; KeyShare offers, yet there is a mutually supported group that can be found via the &#8220;supported_groups&#8221; extension, then the server MUST reply with a HelloRetryRequest.  If there is no mutually supported group at all, the server MUST NOT negotiate an (EC)DHE cipher suite.</p>
<p id="rfc.section.6.3.2.4.p.9">[[TODO: Recommendation about what the client offers.  Presumably which integer DH groups and which curves.]]</p>
<h4 id="rfc.section.6.3.2.4.1"><a href="#rfc.section.6.3.2.4.1">6.3.2.4.1.</a> <a href="#ffdhe-param" id="ffdhe-param">Diffie-Hellman Parameters</a></h4>
<p id="rfc.section.6.3.2.4.1.p.1">Diffie-Hellman <a href="#DH">[DH]</a> parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.  The opaque value contains the Diffie-Hellman public value (Y = g^X mod p), encoded as a big-endian integer, padded with zeros to the size of p.</p>
<p id="rfc.section.6.3.2.4.1.p.2">Note: For a given Diffie-Hellman group, the padding results in all public keys having the same length.</p>
<h4 id="rfc.section.6.3.2.4.2"><a href="#rfc.section.6.3.2.4.2">6.3.2.4.2.</a> <a href="#ecdhe-param" id="ecdhe-param">ECDHE Parameters</a></h4>
<p id="rfc.section.6.3.2.4.2.p.1">ECDHE parameters for both clients and servers are encoded in the the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.</p>
<p id="rfc.section.6.3.2.4.2.p.2">For secp256r1, secp384r1 and secp521r1, the contents are the byte string representation of an elliptic curve public value following the conversion routine in Section 4.3.6 of ANSI X9.62 <a href="#X962">[X962]</a>.</p>
<p id="rfc.section.6.3.2.4.2.p.3">Although X9.62 supports multiple point formats, any given curve MUST specify only a single point format. All curves currently specified in this document MUST only be used with the uncompressed point format (the format for all ECDH functions is considered uncompressed).</p>
<p id="rfc.section.6.3.2.4.2.p.4">For x25519 and x448, the contents are the byte string inputs and outputs of the corresponding functions defined in <a href="#RFC7748">[RFC7748]</a>, 32 bytes for x25519 and 56 bytes for x448.</p>
<p id="rfc.section.6.3.2.4.2.p.5">Note: Versions of TLS prior to 1.3 permitted point negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.</p>
<h4 id="rfc.section.6.3.2.5"><a href="#rfc.section.6.3.2.5">6.3.2.5.</a> <a href="#pre-shared-key-extension" id="pre-shared-key-extension">Pre-Shared Key Extension</a></h4>
<p id="rfc.section.6.3.2.5.p.1">The &#8220;pre_shared_key&#8221; extension is used to indicate the identity of the pre-shared key to be used with a given handshake in association with a PSK or (EC)DHE-PSK cipher suite (see <a href="#RFC4279">[RFC4279]</a> for background).</p>
<p id="rfc.section.6.3.2.5.p.2">Clients which offer one or more PSK cipher suites MUST send at least one supported psk_identity value and servers MUST NOT negotiate any of these cipher suites unless a supported value was provided.  If this extension is not provided and no alternative cipher suite is available, the server MUST close the connection with a fatal &#8220;missing_extension&#8221; alert.  (see <a href="#mti-extensions">Section 8.2</a>)</p>
<p id="rfc.section.6.3.2.5.p.3">The &#8220;extension_data&#8221; field of this extension contains a &#8220;PreSharedKeyExtension&#8221; value:</p>
<pre>
   opaque psk_identity&lt;0..2^16-1&gt;;

   struct {
       select (Role) {
           case client:
               psk_identity identities&lt;2..2^16-1&gt;;

           case server:
               uint16 selected_identity;
       }
   } PreSharedKeyExtension;
</pre>
<p/>

<dl>
  <dt>identities</dt>
  <dd style="margin-left: 8"><br/> A list of the identities (labels for keys) that the client is willing to negotiate with the server.</dd>
  <dt>selected_identity</dt>
  <dd style="margin-left: 8"><br/> The server&#8217;s chosen identity expressed as a (0-based) index into the identies in the client&#8217;s list.</dd>
</dl>
<p id="rfc.section.6.3.2.5.p.5">If no suitable identity is provided, the server MUST NOT negotiate a PSK cipher suite and MAY respond with an &#8220;unknown_psk_identity&#8221; alert message. Sending this alert is OPTIONAL; servers MAY instead choose to send a &#8220;decrypt_error&#8221; alert to merely indicate an invalid PSK identity or instead negotiate use of a non-PSK cipher suite, if available.</p>
<p id="rfc.section.6.3.2.5.p.6">If the server selects a PSK cipher suite, it MUST send a &#8220;pre_shared_key&#8221; extension with the identity that it selected.  The client MUST verify that the server&#8217;s selected_identity is within the range supplied by the client. If any other value is returned, the client MUST generate a fatal &#8220;unknown_psk_identity&#8221; alert and close the connection.</p>
<h4 id="rfc.section.6.3.2.6"><a href="#rfc.section.6.3.2.6">6.3.2.6.</a> <a href="#ocsp-status-extensions" id="ocsp-status-extensions">OCSP Status Extensions</a></h4>
<p><a href="#RFC6066">[RFC6066]</a> and <a href="#RFC6961">[RFC6961]</a> provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server sends an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server&#8217;s OCSP information is carried in an extension in EncryptedExtensions. Specifically: The body of the &#8220;status_request&#8221; or &#8220;status_request_v2&#8221; extension from the server MUST be a CertificateStatus structure as defined in <a href="#RFC6066">[RFC6066]</a> and <a href="#RFC6961">[RFC6961]</a> respectively.</p>
<p id="rfc.section.6.3.2.6.p.2">Note: this means that the certificate status appears prior to the certificates it applies to. This is slightly anomalous but matches the existing behavior for SignedCertificateTimestamps <a href="#RFC6962">[RFC6962]</a>, and is more easily extensible in the handshake state machine.</p>
<h4 id="rfc.section.6.3.2.7"><a href="#rfc.section.6.3.2.7">6.3.2.7.</a> <a href="#early-data-indication" id="early-data-indication">Early Data Indication</a></h4>
<p id="rfc.section.6.3.2.7.p.1">When PSK resumption is used, the client can send application data in its first flight of messages. If the client opts to do so, it MUST supply an &#8220;early_data&#8221; extension as well as the &#8220;pre_shared_key&#8221; extension.</p>
<p id="rfc.section.6.3.2.7.p.2">The &#8220;extension_data&#8221; field of this extension contains an &#8220;EarlyDataIndication&#8221; value:</p>
<pre>
   struct {
       select (Role) {
           case client:
               opaque context&lt;0..255&gt;;

           case server:
              struct {};
       }
   } EarlyDataIndication;
</pre>
<p/>

<dl>
  <dt>context</dt>
  <dd style="margin-left: 8"><br/> An optional context value that can be used for anti-replay (see below).</dd>
</dl>
<p id="rfc.section.6.3.2.7.p.4">All of the parameters for the 0-RTT data (symmetric cipher suite, ALPN, etc.) MUST be those which were negotiated in the connection which established the PSK.  The PSK used to encrypt the early data MUST be the first PSK listed in the client&#8217;s &#8220;pre_shared_key&#8221; extension.</p>
<p id="rfc.section.6.3.2.7.p.5">0-RTT messages sent in the first flight have the same content types as their corresponding messages sent in other flights (handshake, application_data, and alert respectively) but are protected under different keys. After all the 0-RTT application data messages (if any) have been sent, a &#8220;end_of_early_data&#8221; alert of type &#8220;warning&#8221; is sent to indicate the end of the flight.  0-RTT MUST always be followed by an &#8220;end_of_early_data&#8221; alert.</p>
<p id="rfc.section.6.3.2.7.p.6">A server which receives an &#8220;early_data&#8221; extension can behave in one of two ways:</p>
<p/>

<ul>
  <li>Ignore the extension and return no response. This indicates that the server has ignored any early data and an ordinary 1-RTT handshake is required.</li>
  <li>Return an empty extension, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages.</li>
</ul>
<p id="rfc.section.6.3.2.7.p.8">[[OPEN ISSUE: are the rules below correct? https://github.com/tlswg/tls13-spec/issues/451]] Prior to accepting the &#8220;early_data&#8221; extension, the server MUST validate that the session ticket parameters are consistent with its current configuration. It MUST also validate that the extensions negotiated in the previous connection are identical to those being negotiated in the ServerHello, with the exception of the following extensions:</p>
<p/>

<ul>
  <li>The use of &#8220;signed_certificate_timestamp&#8221; <a href="#RFC6962">[RFC6962]</a> MUST be identical but the server&#8217;s SCT extension value may differ.</li>
  <li>The &#8220;padding&#8221; extension <a href="#RFC7685">[RFC7685]</a> MUST be ignored for this purpose.</li>
  <li>The values of &#8220;key_share&#8221;, &#8220;pre_shared_key&#8221;, and &#8220;early_data&#8221;, which MUST be as defined in this document.</li>
</ul>
<p id="rfc.section.6.3.2.7.p.10">In addition, it MUST validate that the ticket_age is within a small tolerance of the time since the ticket was issued (see <a href="#replay-time">Section 6.3.2.7.2</a>).</p>
<p id="rfc.section.6.3.2.7.p.11">If any of these checks fail, the server MUST NOT respond with the extension and must discard all the remaining first flight data (thus falling back to 1-RTT). If the client attempts a 0-RTT handshake but the server rejects it, it will generally not have the 0-RTT record protection keys and must instead trial decrypt each record with the 1-RTT handshake keys until it finds one that decrypts properly, and then pick up the handshake from that point.</p>
<p id="rfc.section.6.3.2.7.p.12">If the server chooses to accept the &#8220;early_data&#8221; extension, then it MUST comply with the same error handling requirements specified for all records when processing early data records.  Specifically, decryption failure of any 0-RTT record following an accepted &#8220;early_data&#8221; extension MUST produce a fatal &#8220;bad_record_mac&#8221; alert as per <a href="#record-payload-protection">Section 5.2.2</a>.  Implementations SHOULD determine the security parameters for the 1-RTT phase of the connection entirely before processing the EncryptedExtensions and Finished, using those values solely to determine whether to accept or reject 0-RTT data.</p>
<p id="rfc.section.6.3.2.7.p.13">[[TODO: How does the client behave if the indication is rejected.]]</p>
<h4 id="rfc.section.6.3.2.7.1"><a href="#rfc.section.6.3.2.7.1">6.3.2.7.1.</a> <a href="#processing-order" id="processing-order">Processing Order</a></h4>
<p id="rfc.section.6.3.2.7.1.p.1">Clients are permitted to &#8220;stream&#8221; 0-RTT data until they receive the server&#8217;s Finished, only then sending the &#8220;end_of_early_data&#8221; alert. In order to avoid deadlock, when accepting &#8220;early_data&#8221;, servers MUST process the client&#8217;s Finished and then immediately send the ServerHello, rather than waiting for the client&#8217;s &#8220;end_of_early_data&#8221; alert.</p>
<h4 id="rfc.section.6.3.2.7.2"><a href="#rfc.section.6.3.2.7.2">6.3.2.7.2.</a> <a href="#replay-time" id="replay-time">Replay Properties</a></h4>
<p id="rfc.section.6.3.2.7.2.p.1">As noted in <a href="#zero-rtt-data">Section 6.2.3</a>, TLS provides only a limited inter-connection mechanism for replay protection for data sent by the client in the first flight.</p>
<p id="rfc.section.6.3.2.7.2.p.2">The &#8220;ticket_age&#8221; extension sent by the client SHOULD be used by servers to limit the time over which the first flight might be replayed.  A server can store the time at which it sends a server configuration to a client, or encode the time in a ticket.  Then, each time it receives an early_data extension, it can check to see if the value used by the client matches its expectations.</p>
<p id="rfc.section.6.3.2.7.2.p.3">The &#8220;ticket_age&#8221; value provided by the client will be shorter than the actual time elapsed on the server by a single round trip time.  This difference is comprised of the delay in sending the NewSessionTicket message to the client, plus the time taken to send the ClientHello to the server.  For this reason, a server SHOULD measure the round trip time prior to sending the NewSessionTicket message and account for that in the value it saves.</p>
<p id="rfc.section.6.3.2.7.2.p.4">There are several potential sources of error that make an exact measurement of time difficult.  Variations in client and server clocks are likely to be minimal, outside of gross time corrections.  Network propagation delays are most likely causes of a mismatch in legitimate values for elapsed time.  Both the NewSessionTicket and ClientHello messages might be retransmitted and therefore delayed, which might be hidden by TCP.</p>
<p id="rfc.section.6.3.2.7.2.p.5">A small allowance for errors in clocks and variations in measurements is advisable.  However, any allowance also increases the opportunity for replay.  In this case, it is better to reject early data than to risk greater exposure to replay attacks.</p>
<h4 id="rfc.section.6.3.2.8"><a href="#rfc.section.6.3.2.8">6.3.2.8.</a> <a href="#ticket-age" id="ticket-age">Ticket Age</a></h4>
<pre>
   struct {
       uint32 ticket_age;
   } TicketAge;
</pre>
<p id="rfc.section.6.3.2.8.p.1">When the client sends the &#8220;early_data&#8221; extension, it MUST also send a &#8220;ticket_age&#8221; extension in its EncryptedExtensions block. This value contains the time elapsed since the client learned about the server configuration that it is using, in milliseconds.  This value can be used by the server to limit the time over which early data can be replayed. Note: because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds.</p>
<h3 id="rfc.section.6.3.3"><a href="#rfc.section.6.3.3">6.3.3.</a> <a href="#server-parameters" id="server-parameters">Server Parameters</a></h3>
<h4 id="rfc.section.6.3.3.1"><a href="#rfc.section.6.3.3.1">6.3.3.1.</a> <a href="#encrypted-extensions" id="encrypted-extensions">Encrypted Extensions</a></h4>
<p id="rfc.section.6.3.3.1.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from handshake_traffic_secret. If the client indicates &#8220;early_data&#8221; in its ClientHello, it MUST also send EncryptedExtensions immediately following the ClientHello and immediately prior to the Finished.</li>
</ul>
<p id="rfc.section.6.3.3.1.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>The EncryptedExtensions message contains any extensions which should be protected, i.e., any which are not needed to establish the cryptographic context.</li>
</ul>
<p id="rfc.section.6.3.3.1.p.5">The same extension types MUST NOT appear in both the ServerHello and EncryptedExtensions.  If the same extension appears in both locations, the client MUST rely only on the value in the EncryptedExtensions block.  All server-sent extensions other than those explicitly listed in <a href="#server-hello">Section 6.3.1.2</a> or designated in the IANA registry MUST only appear in EncryptedExtensions. Extensions which are designated to appear in ServerHello MUST NOT appear in EncryptedExtensions. Clients MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST terminate the handshake with an &#8220;illegal_parameter&#8221; alert.</p>
<p id="rfc.section.6.3.3.1.p.6">The client&#8217;s EncryptedExtensions apply only to the early data with which they appear. Servers MUST NOT use them to negotiate the rest of the handshake. Only those extensions explicitly designated as being included in 0-RTT Encrypted Extensions in the IANA registry can be sent in the client&#8217;s EncryptedExtensions.</p>
<p id="rfc.section.6.3.3.1.p.7">Structure of this message:</p>
<pre>
   struct {
       Extension extensions&lt;0..2^16-1&gt;;
   } EncryptedExtensions;
</pre>
<p/>

<dl>
  <dt>extensions</dt>
  <dd style="margin-left: 8"><br/> A list of extensions.</dd>
</dl>
<h4 id="rfc.section.6.3.3.2"><a href="#rfc.section.6.3.3.2">6.3.3.2.</a> <a href="#certificate-request" id="certificate-request">Certificate Request</a></h4>
<p id="rfc.section.6.3.3.2.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>A non-anonymous server can optionally request a certificate from the client, if appropriate for the selected cipher suite. This message, if sent, will follow EncryptedExtensions.</li>
</ul>
<p id="rfc.section.6.3.3.2.p.3">Structure of this message:</p>
<pre>
   opaque DistinguishedName&lt;1..2^16-1&gt;;

   struct {
       opaque certificate_extension_oid&lt;1..2^8-1&gt;;
       opaque certificate_extension_values&lt;0..2^16-1&gt;;
   } CertificateExtension;

   struct {
       opaque certificate_request_context&lt;0..2^8-1&gt;;
       SignatureScheme
         supported_signature_algorithms&lt;2..2^16-2&gt;;
       DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
       CertificateExtension certificate_extensions&lt;0..2^16-1&gt;;
   } CertificateRequest;
</pre>
<p/>

<dl>
  <dt>certificate_request_context</dt>
  <dd style="margin-left: 8"><br/> An opaque string which identifies the certificate request and which will be echoed in the client&#8217;s Certificate message. The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages).</dd>
  <dt>supported_signature_algorithms</dt>
  <dd style="margin-left: 8"><br/> A list of the signature algorithms that the server is able to verify, listed in descending order of preference. Any certificates provided by the client MUST be signed using a signature algorithm found in supported_signature_algorithms.</dd>
  <dt>certificate_authorities</dt>
  <dd style="margin-left: 8"><br/> A list of the distinguished names <a href="#X501">[X501]</a> of acceptable certificate_authorities, represented in DER-encoded <a href="#X690">[X690]</a> format.  These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space.  If the certificate_authorities list is empty, then the client MAY send any certificate that meets the rest of the selection criteria in the CertificateRequest, unless there is some external arrangement to the contrary.</dd>
  <dt>certificate_extensions</dt>
  <dd style="margin-left: 8"><br/> A list of certificate extension OIDs <a href="#RFC5280">[RFC5280]</a> with their allowed values, represented in DER-encoded <a href="#X690">[X690]</a> format. Some certificate extension OIDs allow multiple values (e.g. Extended Key Usage).  If the server has included a non-empty certificate_extensions list, the client certificate MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client has ignored some of the required certificate extension OIDs, and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the session without client authentication, or terminate the session with a fatal unsupported_certificate alert.  PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.  This document defines matching rules for two standard certificate extensions defined in <a href="#RFC5280">[RFC5280]</a>: <ul><li>The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.</li><li>The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request.</li></ul><p> Separate specifications may define matching rules for other certificate extensions.</p></dd>
</dl>
<p id="rfc.section.6.3.3.2.p.5">Note: It is a fatal &#8220;handshake_failure&#8221; alert for an anonymous server to request client authentication.</p>
<h3 id="rfc.section.6.3.4"><a href="#rfc.section.6.3.4">6.3.4.</a> <a href="#authentication-messages" id="authentication-messages">Authentication Messages</a></h3>
<p id="rfc.section.6.3.4.p.1">As discussed in <a href="#handshake-protocol-overview">Section 6.2</a>, TLS uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These messages are always sent as the last messages in their handshake flight. The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below. The Finished message is always sent as part of the Authentication block.</p>
<p id="rfc.section.6.3.4.p.2">The computations for the Authentication messages all uniformly take the following inputs:</p>
<p/>

<ul>
  <li>The certificate and signing key to be used.</li>
  <li>A Handshake Context based on the hash of the handshake messages</li>
  <li>A base key to be used to compute a MAC key.</li>
</ul>
<p id="rfc.section.6.3.4.p.4">Based on these inputs, the messages then contain:</p>
<p/>

<dl>
  <dt>Certificate</dt>
  <dd style="margin-left: 8"><br/> The certificate to be used for authentication and any supporting certificates in the chain. Note that certificate-based client authentication is not available in the 0-RTT case.</dd>
  <dt>CertificateVerify</dt>
  <dd style="margin-left: 8"><br/> A signature over the value Hash(Handshake Context + Certificate) + Hash(resumption_context) See <a href="#new-session-ticket-message">Section 6.3.5.1</a> for the definition of resumption_context.</dd>
  <dt>Finished</dt>
  <dd style="margin-left: 8"><br/> A MAC over the value Hash(Handshake Context + Certificate + CertificateVerify) + Hash(resumption_context) using  a MAC key derived from the base key.</dd>
</dl>
<p id="rfc.section.6.3.4.p.6">Because the CertificateVerify signs the Handshake Context + Certificate and the Finished MACs the Handshake Context + Certificate + CertificateVerify, this is mostly equivalent to keeping a running hash of the handshake messages (exactly so in the pure 1-RTT cases). Note, however, that subsequent post-handshake authentications do not include each other, just the messages through the end of the main handshake.</p>
<p id="rfc.section.6.3.4.p.7">The following table defines the Handshake Context and MAC Base Key for each scenario:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Mode</th>
      <th class="left">Handshake Context</th>
      <th class="left">Base Key</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0-RTT</td>
      <td class="left">ClientHello</td>
      <td class="left">early_traffic_secret</td>
    </tr>
    <tr>
      <td class="left">1-RTT (Server)</td>
      <td class="left">ClientHello &#8230; later of EncryptedExtensions/CertificateRequest</td>
      <td class="left">handshake_traffic_secret</td>
    </tr>
    <tr>
      <td class="left">1-RTT (Client)</td>
      <td class="left">ClientHello &#8230; ServerFinished</td>
      <td class="left">handshake_traffic_secret</td>
    </tr>
    <tr>
      <td class="left">Post-Handshake</td>
      <td class="left">ClientHello &#8230; ClientFinished + CertificateRequest</td>
      <td class="left">traffic_secret_0</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.3.4.p.8">Note: The Handshake Context for the last three rows does not include any 0-RTT handshake messages, regardless of whether 0-RTT is used.</p>
<h4 id="rfc.section.6.3.4.1"><a href="#rfc.section.6.3.4.1">6.3.4.1.</a> <a href="#certificate" id="certificate">Certificate</a></h4>
<p id="rfc.section.6.3.4.1.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).</li>
</ul>
<p/>

<ul class="empty">
  <li>The client MUST send a Certificate message if and only if server has requested client authentication via a CertificateRequest message (<a href="#certificate-request">Section 6.3.3.2</a>). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the &#8220;certificate_list&#8221; field having length 0).</li>
</ul>
<p id="rfc.section.6.3.4.1.p.4">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>This message conveys the endpoint&#8217;s certificate chain to the peer.</li>
</ul>
<p/>

<ul class="empty">
  <li>The certificate MUST be appropriate for the negotiated cipher suite&#8217;s key exchange algorithm and any negotiated extensions.</li>
</ul>
<p id="rfc.section.6.3.4.1.p.7">Structure of this message:</p>
<pre>
   opaque ASN1Cert&lt;1..2^24-1&gt;;

   struct {
       opaque certificate_request_context&lt;0..2^8-1&gt;;
       ASN1Cert certificate_list&lt;0..2^24-1&gt;;
   } Certificate;
</pre>
<p/>

<dl>
  <dt>certificate_request_context:</dt>
  <dd style="margin-left: 8"><br/> If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise, in the case of server authentication or client authentication in 0-RTT, this field SHALL be zero length.</dd>
  <dt>certificate_list</dt>
  <dd style="margin-left: 8"><br/> This is a sequence (chain) of certificates. The sender&#8217;s certificate MUST come first in the list. Each following certificate SHOULD directly certify one preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.</dd>
</dl>
<p id="rfc.section.6.3.4.1.p.9">Note: Prior to TLS 1.3, &#8220;certificate_list&#8221; ordering required each certificate to certify the one immediately preceding it, however some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.</p>
<p id="rfc.section.6.3.4.1.p.10">The server&#8217;s certificate list MUST always be non-empty. A client will send an empty certificate list if it does not have an appropriate certificate to send in response to the server&#8217;s authentication request.</p>
<h4 id="rfc.section.6.3.4.1.1"><a href="#rfc.section.6.3.4.1.1">6.3.4.1.1.</a> <a href="#server-certificate-selection" id="server-certificate-selection">Server Certificate Selection</a></h4>
<p id="rfc.section.6.3.4.1.1.p.1">The following rules apply to the certificates sent by the server:</p>
<p/>

<ul>
  <li>The certificate type MUST be X.509v3 <a href="#RFC5280">[RFC5280]</a>, unless explicitly negotiated otherwise (e.g., <a href="#RFC5081">[RFC5081]</a>).</li>
  <li>The server&#8217;s end-entity certificate&#8217;s public key (and associated restrictions) MUST be compatible with the selected key exchange algorithm.</li>
</ul>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Key Exchange Alg.</th>
      <th class="left">Certificate Key Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">DHE_RSA or ECDHE_RSA</td>
      <td class="left">RSA public key</td>
    </tr>
    <tr>
      <td class="left">ECDHE_ECDSA</td>
      <td class="left">ECDSA or EdDSA public key</td>
    </tr>
  </tbody>
</table>
<p/>

<ul>
  <li>The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client&#8217;s &#8220;signature_algorithms&#8221; extension.</li>
  <li>The &#8220;server_name&#8221; and &#8220;trusted_ca_keys&#8221; extensions <a href="#RFC6066">[RFC6066]</a> are used to guide certificate selection. As servers MAY require the presence of the &#8220;server_name&#8221; extension, clients SHOULD send this extension.</li>
</ul>
<p id="rfc.section.6.3.4.1.1.p.4">All certificates provided by the server MUST be signed by a signature algorithm that appears in the &#8220;signature_algorithms&#8221; extension provided by the client, if they are able to provide such a chain (see <a href="#signature-algorithms">Section 6.3.2.2</a>).  Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.</p>
<p id="rfc.section.6.3.4.1.1.p.5">If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain MAY use the deprecated SHA-1 hash algorithm only if the &#8220;signature_algorithms&#8221; extension provided by the client permits it.  If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST send an &#8220;unsupported_certificate&#8221; alert message and close the connection.</p>
<p id="rfc.section.6.3.4.1.1.p.6">If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport layer endpoint, local configuration and preferences).</p>
<p id="rfc.section.6.3.4.1.1.p.7">As cipher suites that specify new key exchange methods are specified for the TLS protocol, they will imply the certificate format and the required encoded keying information.</p>
<h4 id="rfc.section.6.3.4.1.2"><a href="#rfc.section.6.3.4.1.2">6.3.4.1.2.</a> <a href="#client-certificate-selection" id="client-certificate-selection">Client Certificate Selection</a></h4>
<p id="rfc.section.6.3.4.1.2.p.1">The following rules apply to certificates sent by the client:</p>
<p id="rfc.section.6.3.4.1.2.p.2">In particular:</p>
<p/>

<ul>
  <li>The certificate type MUST be X.509v3 <a href="#RFC5280">[RFC5280]</a>, unless explicitly negotiated otherwise (e.g., <a href="#RFC5081">[RFC5081]</a>).</li>
  <li>If the certificate_authorities list in the certificate request message was non-empty, one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.</li>
  <li>The certificates MUST be signed using an acceptable hash/ signature algorithm pair, as described in <a href="#certificate-request">Section 6.3.3.2</a>.  Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.</li>
  <li>If the certificate_extensions list in the certificate request message was non-empty, the end-entity certificate MUST match the extension OIDs recognized by the client, as described in <a href="#certificate-request">Section 6.3.3.2</a>.</li>
</ul>
<p id="rfc.section.6.3.4.1.2.p.4">Note that, as with the server certificate, there are certificates that use algorithm combinations that cannot be currently used with TLS.</p>
<h4 id="rfc.section.6.3.4.1.3"><a href="#rfc.section.6.3.4.1.3">6.3.4.1.3.</a> <a href="#receiving-a-certificate-message" id="receiving-a-certificate-message">Receiving a Certificate Message</a></h4>
<p id="rfc.section.6.3.4.1.3.p.1">In general, detailed certificate validation procedures are out of scope for TLS (see <a href="#RFC5280">[RFC5280]</a>). This section provides TLS-specific requirements.</p>
<p id="rfc.section.6.3.4.1.3.p.2">If the server supplies an empty Certificate message, the client MUST terminate the handshake with a fatal &#8220;decode_error&#8221; alert.</p>
<p id="rfc.section.6.3.4.1.3.p.3">If the client does not send any certificates, the server MAY at its discretion either continue the handshake without client authentication, or respond with a fatal &#8220;handshake_failure&#8221; alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or send a fatal alert.</p>
<p id="rfc.section.6.3.4.1.3.p.4">Any endpoint receiving any certificate signed using any signature algorithm using an MD5 hash MUST send a &#8220;bad_certificate&#8221; alert message and close the connection.</p>
<p id="rfc.section.6.3.4.1.3.p.5">SHA-1 is deprecated and therefore NOT RECOMMENDED.  Endpoints that reject certification paths due to use of a deprecated hash MUST send a fatal &#8220;bad_certificate&#8221; alert message before closing the connection.  All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.</p>
<p id="rfc.section.6.3.4.1.3.p.6">Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).</p>
<h4 id="rfc.section.6.3.4.2"><a href="#rfc.section.6.3.4.2">6.3.4.2.</a> <a href="#certificate-verify" id="certificate-verify">Certificate Verify</a></h4>
<p id="rfc.section.6.3.4.2.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate and also provides integrity for the handshake up to this point. Servers MUST send this message when using a cipher suite which is authenticated via a certificate.  Clients MUST send this message whenever authenticating via a Certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate Message and immediately prior to the Finished message.</li>
</ul>
<p id="rfc.section.6.3.4.2.p.3">Structure of this message:</p>
<pre>
   struct {
        digitally-signed struct {
           opaque hashed_data[hash_length];
        };
   } CertificateVerify;
</pre>
<p/>

<ul class="empty">
  <li>Where hashed_data is the hash output described in <a href="#authentication-messages">Section 6.3.4</a>, namely Hash(Handshake Context + Certificate) + Hash(resumption_context). For concreteness, this means that the value that is signed is:</li>
</ul>
<pre>
       padding + context_string + 00 + hashed_data
</pre>
<p/>

<ul class="empty">
  <li>The context string for a server signature is &#8220;TLS 1.3, server CertificateVerify&#8221; and for a client signature is &#8220;TLS 1.3, client CertificateVerify&#8221;. A hash of the handshake messages is signed rather than the messages themselves because the digitally-signed format requires padding and context bytes at the beginning of the input. Thus, by signing a digest of the messages, an implementation only needs to maintain a single running hash per hash type for CertificateVerify, Finished and other messages.</li>
</ul>
<p/>

<ul class="empty">
  <li>If sent by a server, the signature algorithm MUST be one offered in the client&#8217;s &#8220;signature_algorithms&#8221; extension unless no valid certificate chain can be produced without unsupported algorithms (see <a href="#signature-algorithms">Section 6.3.2.2</a>). Note that there is a possibility for inconsistencies here. For instance, the client might offer ECDHE_ECDSA key exchange but omit any ECDSA and EdDSA values from its &#8220;signature_algorithms&#8221; extension. In order to negotiate correctly, the server MUST check any candidate cipher suites against the &#8220;signature_algorithms&#8221; extension before selecting them. This is somewhat inelegant but is a compromise designed to minimize changes to the original cipher suite design.</li>
</ul>
<p/>

<ul class="empty">
  <li>If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the CertificateRequest message.</li>
</ul>
<p/>

<ul class="empty">
  <li>In addition, the signature algorithm MUST be compatible with the key in the sender&#8217;s end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS-v1_5 algorithms appear in &#8220;signature_algorithms&#8221;. SHA-1 MUST NOT be used in any signatures in CertificateVerify. (Note that rsa_pkcs1_sha1 and dsa_sha1, the only defined SHA-1 signature algorithms, are undefined for CertificateVerify signatures.)</li>
</ul>
<p id="rfc.section.6.3.4.2.p.9">Note: When used with non-certificate-based handshakes (e.g., PSK), the client&#8217;s signature does not cover the server&#8217;s certificate directly, although it does cover the server&#8217;s Finished message, which transitively includes the server&#8217;s certificate when the PSK derives from a certificate-authenticated handshake.  <a href="#PSK-FINISHED">[PSK-FINISHED]</a> describes a concrete attack on this mode if the Finished is omitted from the signature. It is unsafe to use certificate-based client authentication when the client might potentially share the same PSK/key-id pair with two different endpoints. In order to ensure this, implementations MUST NOT mix certificate-based client authentication with pure PSK modes (i.e., those where the PSK was not derived from a previous non-PSK handshake).</p>
<h4 id="rfc.section.6.3.4.3"><a href="#rfc.section.6.3.4.3">6.3.4.3.</a> <a href="#finished" id="finished">Finished</a></h4>
<p id="rfc.section.6.3.4.3.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The Finished message is the final message in the authentication block. It is essential for providing authentication of the handshake and of the computed keys.</li>
</ul>
<p id="rfc.section.6.3.4.3.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>Recipients of Finished messages MUST verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.</li>
</ul>
<p id="rfc.section.6.3.4.3.p.5">The key used to compute the finished message is computed from the Base key defined in <a href="#authentication-messages">Section 6.3.4</a> using HKDF (see <a href="#key-schedule">Section 7.1</a>). Specifically:</p>
<pre>
client_finished_key =
    HKDF-Expand-Label(BaseKey, "client finished", "", L)

server_finished_key =
    HKDF-Expand-Label(BaseKey, "server finished", "", L)
</pre>
<p id="rfc.section.6.3.4.3.p.6">Structure of this message:</p>
<pre>
   struct {
       opaque verify_data[verify_data_length];
   } Finished;
</pre>
<p id="rfc.section.6.3.4.3.p.7">The verify_data value is computed as follows:</p>
<pre>
   verify_data =
       HMAC(finished_key, Hash(
              Handshake Context + Certificate* + CertificateVerify* 
           ) + Hash(resumption_context)
           )

   * Only included if present.
</pre>
<p id="rfc.section.6.3.4.3.p.8">Where HMAC <a href="#RFC2104">[RFC2104]</a> uses the Hash algorithm for the handshake.  As noted above: the HMAC input can generally be implemented by a running hash, i.e., just the handshake hash at this point.</p>
<p id="rfc.section.6.3.4.3.p.9">In previous versions of TLS, the verify_data was always 12 octets long. In the current version of TLS, it is the size of the HMAC output for the Hash used for the handshake.</p>
<p id="rfc.section.6.3.4.3.p.10">Note: Alerts and any other record types are not handshake messages and are not included in the hash computations.</p>
<h3 id="rfc.section.6.3.5"><a href="#rfc.section.6.3.5">6.3.5.</a> <a href="#post-handshake-messages" id="post-handshake-messages">Post-Handshake Messages</a></h3>
<p id="rfc.section.6.3.5.p.1">TLS also allows other messages to be sent after the main handshake.  These messages use a handshake content type and are encrypted under the application traffic key.</p>
<h4 id="rfc.section.6.3.5.1"><a href="#rfc.section.6.3.5.1">6.3.5.1.</a> <a href="#new-session-ticket-message" id="new-session-ticket-message">New Session Ticket Message</a></h4>
<p id="rfc.section.6.3.5.1.p.1">At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a pre-shared key (PSK) binding between the ticket value and the following two values derived from the resumption master secret:</p>
<pre>
   resumption_psk = HKDF-Expand-Label(resumption_secret,
                                      "resumption psk", "", L)

   resumption_context = HKDF-Expand-Label(resumption_secret,
                                          "resumption context", "", L)
</pre>
<p id="rfc.section.6.3.5.1.p.2">The client MAY use this PSK for future handshakes by including the ticket value in the &#8220;pre_shared_key&#8221; extension in its ClientHello (<a href="#pre-shared-key-extension">Section 6.3.2.5</a>) and supplying a suitable PSK cipher suite. Servers may send multiple tickets on a single connection, for instance after post-handshake authentication. For handshakes that do not use a resumption_psk, the resumption_context is a string of L zeroes.</p>
<pre>
 enum { (65535) } TicketExtensionType;

 struct {
     TicketExtensionType extension_type;
     opaque extension_data&lt;0..2^16-1&gt;;
 } TicketExtension;

 enum {
   allow_early_data(1)
   allow_dhe_resumption(2),
   allow_psk_resumption(4)
 } TicketFlags;
 
 struct {
     uint32 ticket_lifetime;
     uint32 flags;
     TicketExtension extensions&lt;2..2^16-2&gt;;
     opaque ticket&lt;0..2^16-1&gt;;
 } NewSessionTicket;
</pre>
<p/>

<dl>
  <dt>flags</dt>
  <dd style="margin-left: 8"><br/> A 32-bit value indicating the ways in which this ticket may be used (as an OR of the flags values).</dd>
  <dt>ticket_lifetime</dt>
  <dd style="margin-left: 8"><br/> Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance.  Servers MUST NOT use any value more than 604800 seconds (7 days).  The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache session tickets for longer than 7 days, regardless of the ticket_lifetime. It MAY delete the ticket earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.</dd>
  <dt>ticket_extensions</dt>
  <dd style="margin-left: 8"><br/> A placeholder for extensions in the ticket. Clients MUST ignore unrecognized extensions.</dd>
  <dt>ticket</dt>
  <dd style="margin-left: 8"><br/> The value of the ticket to be used as the PSK identifier.  The ticket itself is an opaque label. It MAY either be a database lookup key or a self-encrypted and self-authenticated value. Section 4 of <a href="#RFC5077">[RFC5077]</a> describes a recommended ticket construction mechanism.</dd>
</dl>
<p id="rfc.section.6.3.5.1.p.4">The meanings of the flags are as follows:</p>
<p/>

<dl>
  <dt>allow_early_data</dt>
  <dd style="margin-left: 8"><br/> When resuming with this ticket, the client MAY send data in its first flight (early data) encrypted under a key derived from this PSK.</dd>
  <dt>allow_dhe_resumption</dt>
  <dd style="margin-left: 8"><br/> This ticket MAY be used with (EC)DHE-PSK cipher suite</dd>
  <dt>allow_psk_resumption</dt>
  <dd style="margin-left: 8"><br/> This ticket MAY be used with a pure PSK cipher suite.</dd>
</dl>
<p id="rfc.section.6.3.5.1.p.6">In all cases, the PSK or (EC)DHE-PSK cipher suites that the client offers/uses MUST have the same symmetric parameters (cipher/hash) as the cipher suite negotiated for this connection. If no flags are set that the client recognizes, it MUST ignore the ticket.</p>
<h4 id="rfc.section.6.3.5.2"><a href="#rfc.section.6.3.5.2">6.3.5.2.</a> <a href="#post-handshake-authentication" id="post-handshake-authentication">Post-Handshake Authentication</a></h4>
<p id="rfc.section.6.3.5.2.p.1">The server is permitted to request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client SHOULD respond with the appropriate Authentication messages. If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished.</p>
<p id="rfc.section.6.3.5.2.p.2">Note: Because client authentication may require prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).</p>
<h4 id="rfc.section.6.3.5.3"><a href="#rfc.section.6.3.5.3">6.3.5.3.</a> <a href="#key-update" id="key-update">Key and IV Update</a></h4>
<p id="rfc.section.6.3.5.3.p.1">struct {} KeyUpdate;</p>
<p id="rfc.section.6.3.5.3.p.2">The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by the server after sending its first flight and the client after sending its second flight. Implementations that receive a KeyUpdate message prior to receiving a Finished message as part of the 1-RTT handshake MUST generate a fatal &#8220;unexpected_message&#8221; alert.  After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in <a href="#updating-traffic-keys">Section 7.2</a>. Upon receiving a KeyUpdate, the receiver MUST update their receiving keys and if they have not already updated their sending state up to or past the then current receiving generation MUST send their own KeyUpdate prior to sending any other messages.  This mechanism allows either side to force an update to the entire connection. Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate and receiving the peer&#8217;s KeyUpdate because those messages may already be in flight.</p>
<p id="rfc.section.6.3.5.3.p.3">Note that if implementations independently send their own KeyUpdates and they cross in flight, this only results in an update of one generation; when each side receives the other side&#8217;s update it just updates its receive keys and notes that the generations match and thus no send update is needed.</p>
<p id="rfc.section.6.3.5.3.p.4">Note that the side which sends its KeyUpdate first needs to retain the traffic keys (though not the traffic secret) for the previous generation of keys until it receives the KeyUpdate from the other side.</p>
<p id="rfc.section.6.3.5.3.p.5">Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#cryptographic-computations" id="cryptographic-computations">Cryptographic Computations</a></h1>
<p id="rfc.section.7.p.1">In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, key exchange, and record protection algorithms are determined by the cipher_suite selected by the server and revealed in the ServerHello message. The random values are exchanged in the hello messages. All that remains is to calculate the key schedule.</p>
<h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#key-schedule" id="key-schedule">Key Schedule</a></h2>
<p id="rfc.section.7.1.p.1">The TLS handshake establishes one or more input secrets which are combined to create the actual working keying material, as detailed below. The key derivation process makes use of the following functions, based on HKDF <a href="#RFC5869">[RFC5869]</a>:</p>
<pre>
  HKDF-Extract(Salt, IKM) as defined in {{RFC5869}}.
  
  HKDF-Expand-Label(Secret, Label, Messages, Length) =
       HKDF-Expand(Secret, HkdfLabel, Length)

  Where HkdfLabel is specified as:

  struct HkdfLabel {
    uint16 length;
    opaque label&lt;9..255&gt;;
    opaque hash_value&lt;0..255&gt;;
  };

  - HkdfLabel.length is Length
  - HkdfLabel.label is "TLS 1.3, " + Label
  - HkdfLabel.hash_value is HashValue.

  Derive-Secret(Secret, Label, Messages) =
       HKDF-Expand-Label(Secret, Label,
                         Hash(Messages) + Hash(resumption_context), L))
</pre>
<p id="rfc.section.7.1.p.2">Given a set of n InputSecrets, the final &#8220;master secret&#8221; is computed by iteratively invoking HKDF-Extract with InputSecret_1, InputSecret_2, etc.  The initial secret is simply a string of 0s as long as the size of the Hash that is the basis for the HKDF. Concretely, for the present version of TLS 1.3, secrets are added in the following order:</p>
<p/>

<ul>
  <li>PSK</li>
  <li>(EC)DHE shared secret</li>
</ul>
<p id="rfc.section.7.1.p.4">This produces a full key derivation schedule shown in the diagram below.  In this diagram, the following formatting conventions apply:</p>
<p/>

<ul>
  <li>HKDF-Extract is drawn as taking the Salt argument from the top and the IKM argument from the left.</li>
  <li>Derive-Secret&#8217;s Secret argument is indicated by the arrow coming in from the left. For instance, the Early Secret is the Secret for generating the early_traffic-secret.</li>
</ul>
<pre>
                 0
                 |
                 v
   PSK -&gt;  HKDF-Extract
                 |
                 v
           Early Secret  --&gt; Derive-Secret(., "early traffic secret",
                 |                         ClientHello)
                 |                         = early_traffic_secret 
                 v
(EC)DHE -&gt; HKDF-Extract
                 |
                 v
              Handshake
               Secret -----&gt; Derive-Secret(., "handshake traffic secret",
                 |                         ClientHello + ServerHello)
                 |                         = handshake_traffic_secret
                 v
      0 -&gt; HKDF-Extract
                 |
                 v
            Master Secret
                 |
                 +---------&gt; Derive-Secret(., "application traffic secret",
                 |                         ClientHello...Server Finished)
                 |                         = traffic_secret_0
                 |                        
                 +---------&gt; Derive-Secret(., "exporter master secret",
                 |                         ClientHello...Client Finished)
                 |                         = exporter_secret       
                 |
                 +---------&gt; Derive-Secret(., "resumption master secret",
                                           ClientHello...Client Finished)
                                           = resumption_secret
</pre>
<p id="rfc.section.7.1.p.6">The general pattern here is that the secrets shown down the left side of the diagram are just raw entropy without context, whereas the secrets down the right side include handshake context and therefore can be used to derive working keys without additional context.  Note that the different calls to Derive-Secret may take different Messages arguments, even with the same secret. In a 0-RTT exchange, Derive-Secret is called with four distinct transcripts; in a 1-RTT only exchange with three distinct transcripts.</p>
<p id="rfc.section.7.1.p.7">If a given secret is not available, then the 0-value consisting of a string of L zeroes is used.</p>
<h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#updating-traffic-keys" id="updating-traffic-keys">Updating Traffic Keys and IVs</a></h2>
<p id="rfc.section.7.2.p.1">Once the handshake is complete, it is possible for either side to update its sending traffic keys using the KeyUpdate handshake message <a href="#key-update">Section 6.3.5.3</a>.  The next generation of traffic keys is computed by generating traffic_secret_N+1 from traffic_secret_N as described in this section then re-deriving the traffic keys as described in <a href="#traffic-key-calculation">Section 7.3</a>.</p>
<p id="rfc.section.7.2.p.2">The next-generation traffic_secret is computed as:</p>
<p id="rfc.section.7.2.p.3">traffic_secret_N+1 = HKDF-Expand-Label(traffic_secret_N, &#8220;application traffic secret&#8221;, &#8220;&#8221;, L)</p>
<p id="rfc.section.7.2.p.4">Once traffic_secret_N+1 and its associated traffic keys have been computed, implementations SHOULD delete traffic_secret_N. Once the directional keys are no longer needed, they SHOULD be deleted as well.</p>
<h2 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#traffic-key-calculation" id="traffic-key-calculation">Traffic Key Calculation</a></h2>
<p id="rfc.section.7.3.p.1">The traffic keying material is generated from the following input values:</p>
<p/>

<ul>
  <li>A secret value</li>
  <li>A phase value indicating the phase of the protocol the keys are being generated for.</li>
  <li>A purpose value indicating the specific value being generated</li>
  <li>The length of the key.</li>
</ul>
<p id="rfc.section.7.3.p.3">The keying material is computed using:</p>
<pre>
   key = HKDF-Expand-Label(Secret,
                           phase + ", " + purpose, "",
                           key_length)
</pre>
<p id="rfc.section.7.3.p.4">The following table describes the inputs to the key calculation for each class of traffic keys:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Record Type</th>
      <th class="left">Secret</th>
      <th class="left">Phase</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0-RTT Handshake</td>
      <td class="left">early_traffic_secret</td>
      <td class="left">&#8220;early handshake key expansion&#8221;</td>
    </tr>
    <tr>
      <td class="left">0-RTT Application</td>
      <td class="left">early_traffic_secret</td>
      <td class="left">&#8220;early application data key expansion&#8221;</td>
    </tr>
    <tr>
      <td class="left">Handshake</td>
      <td class="left">handshake_traffic_secret</td>
      <td class="left">&#8220;handshake key expansion&#8221;</td>
    </tr>
    <tr>
      <td class="left">Application Data</td>
      <td class="left">traffic_secret_N</td>
      <td class="left">&#8220;application data key expansion&#8221;</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.7.3.p.5">The following table indicates the purpose values for each type of key:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Key Type</th>
      <th class="left">Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">Client Write Key</td>
      <td class="left">&#8220;client write key&#8221;</td>
    </tr>
    <tr>
      <td class="left">Server Write Key</td>
      <td class="left">&#8220;server write key&#8221;</td>
    </tr>
    <tr>
      <td class="left">Client Write IV</td>
      <td class="left">&#8220;client write iv&#8221;</td>
    </tr>
    <tr>
      <td class="left">Server Write IV</td>
      <td class="left">&#8220;server write iv&#8221;</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.7.3.p.6">All the traffic keying material is recomputed whenever the underlying Secret changes (e.g., when changing from the handshake to application data keys or upon a key update).</p>
<h3 id="rfc.section.7.3.1"><a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#diffie-hellman" id="diffie-hellman">Diffie-Hellman</a></h3>
<p id="rfc.section.7.3.1.p.1">A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is converted to byte string by encoding in big-endian, padded with zeros up to the size of the prime. This byte string is used as the shared secret, and is used in the key schedule as specified above.</p>
<p id="rfc.section.7.3.1.p.2">Note that this construction differs from previous versions of TLS which remove leading zeros.</p>
<h3 id="rfc.section.7.3.2"><a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#elliptic-curve-diffie-hellman" id="elliptic-curve-diffie-hellman">Elliptic Curve Diffie-Hellman</a></h3>
<p id="rfc.section.7.3.2.p.1">For secp256r1, secp384r1 and secp521r1, ECDH calculations (including parameter and key generation as well as the shared secret calculation) are performed according to <a href="#IEEE1363">[IEEE1363]</a> using the ECKAS-DH1 scheme with the identity map as key derivation function (KDF), so that the shared secret is the x-coordinate of the ECDH shared secret elliptic curve point represented as an octet string.  Note that this octet string (Z in IEEE 1363 terminology) as output by FE2OSP, the Field Element to Octet String Conversion Primitive, has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.</p>
<p id="rfc.section.7.3.2.p.2">(Note that this use of the identity KDF is a technicality.  The complete picture is that ECDH is employed with a non-trivial KDF because TLS does not directly use this secret for anything other than for computing other secrets.)</p>
<p id="rfc.section.7.3.2.p.3">ECDH functions are used as follows:</p>
<p/>

<ul>
  <li>The public key to put into the KeyShareEntry.key_exchange structure is the result of applying the ECDH function to the secret key of appropriate length (into scalar input) and the standard public basepoint (into u-coordinate point input).</li>
  <li>The ECDH shared secret is the result of applying ECDH function to the secret key (into scalar input) and the peer&#8217;s public key (into u-coordinate point input). The output is used raw, with no processing.</li>
</ul>
<p id="rfc.section.7.3.2.p.5">For X25519 and X448, see <a href="#RFC7748">[RFC7748]</a>.</p>
<h3 id="rfc.section.7.3.3"><a href="#rfc.section.7.3.3">7.3.3.</a> <a href="#exporters" id="exporters">Exporters</a></h3>
<p><a href="#RFC5705">[RFC5705]</a> defines keying material exporters for TLS in terms of the TLS PRF. This document replaces the PRF with HKDF, thus requiring a new construction. The exporter interface remains the same, however the value is computed as:</p>
<pre>
HKDF-Expand-Label(exporter_secret,
                  label, context_value, key_length)
</pre>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#mandatory-algorithms" id="mandatory-algorithms">Mandatory Algorithms</a></h1>
<h2 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#mti-cipher-suites" id="mti-cipher-suites">MTI Cipher Suites</a></h2>
<p id="rfc.section.8.1.p.1">In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following cipher suites:</p>
<pre>
    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
</pre>
<p id="rfc.section.8.1.p.2">These cipher suites MUST support both digital signatures and key exchange with secp256r1 (NIST P-256) and SHOULD support key exchange with X25519 <a href="#RFC7748">[RFC7748]</a>.</p>
<p id="rfc.section.8.1.p.3">A TLS-compliant application SHOULD implement the following cipher suites:</p>
<pre>
    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
</pre>
<h2 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#mti-extensions" id="mti-extensions">MTI Extensions</a></h2>
<p id="rfc.section.8.2.p.1">In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions:</p>
<p/>

<ul>
  <li>Signature Algorithms (&#8220;signature_algorithms&#8221;; <a href="#signature-algorithms">Section 6.3.2.2</a>)</li>
  <li>Negotiated Groups (&#8220;supported_groups&#8221;; <a href="#negotiated-groups">Section 6.3.2.3</a>)</li>
  <li>Key Share (&#8220;key_share&#8221;; <a href="#key-share">Section 6.3.2.4</a>)</li>
  <li>Pre-Shared Key (&#8220;pre_shared_key&#8221;; <a href="#pre-shared-key-extension">Section 6.3.2.5</a>)</li>
  <li>Server Name Indication (&#8220;server_name&#8221;; Section 3 of <a href="#RFC6066">[RFC6066]</a>)</li>
  <li>Cookie (&#8220;cookie&#8221;; <a href="#cookie">Section 6.3.2.1</a>)</li>
</ul>
<p id="rfc.section.8.2.p.3">All implementations MUST send and use these extensions when offering applicable cipher suites:</p>
<p/>

<ul>
  <li>&#8220;signature_algorithms&#8221; is REQUIRED for certificate authenticated cipher suites</li>
  <li>&#8220;supported_groups&#8221; and &#8220;key_share&#8221; are REQUIRED for DHE or ECDHE cipher suites</li>
  <li>&#8220;pre_shared_key&#8221; is REQUIRED for PSK cipher suites</li>
  <li>&#8220;cookie&#8221; is REQUIRED for all cipher suites.</li>
</ul>
<p id="rfc.section.8.2.p.5">When negotiating use of applicable cipher suites, endpoints MUST abort the connection with a &#8220;missing_extension&#8221; alert if the required extension was not provided. Any endpoint that receives any invalid combination of cipher suites and extensions MAY abort the connection with a &#8220;missing_extension&#8221; alert, regardless of negotiated parameters.</p>
<p id="rfc.section.8.2.p.6">Additionally, all implementations MUST support use of the &#8220;server_name&#8221; extension with applications capable of using it.  Servers MAY require clients to send a valid &#8220;server_name&#8221; extension.  Servers requiring this extension SHOULD respond to a ClientHello lacking a &#8220;server_name&#8221; extension with a fatal &#8220;missing_extension&#8221; alert.</p>
<p id="rfc.section.8.2.p.7">Servers MUST NOT send the &#8220;signature_algorithms&#8221; extension; if a client receives this extension it MUST respond with a fatal &#8220;unsupported_extension&#8221; alert and close the connection.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#application-data-protocol" id="application-data-protocol">Application Data Protocol</a></h1>
<p id="rfc.section.9.p.1">Application data messages are carried by the record layer and are fragmented and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.10.p.1">Security issues are discussed throughout this memo, especially in Appendices B, C, and D.</p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.11.p.1">This document uses several registries that were originally created in <a href="#RFC4346">[RFC4346]</a>. IANA has updated these to reference this document. The registries and their allocation policies are below:</p>
<p/>

<ul>
  <li>TLS Cipher Suite Registry: Values with the first byte in the range 0-254 (decimal) are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values with the first byte 255 (decimal) are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>. IANA [SHALL add/has added] a &#8220;Recommended&#8221; column to the cipher suite registry. All cipher suites listed in <a href="#cipher-suites">Appendix A.4</a> are marked as &#8220;Yes&#8221;. All other cipher suites are marked as &#8220;No&#8221;. IANA [SHALL add/has added] add a note to this column reading:  <ul class="empty"><li>Cipher suites marked as &#8220;Yes&#8221; are those allocated via Standards Track RFCs. Cipher suites marked as &#8220;No&#8221; are not; cipher suites marked &#8220;No&#8221; range from &#8220;good&#8221; to &#8220;bad&#8221; from a cryptographic standpoint.</li></ul></li>
  <li>TLS ContentType Registry: Future values are allocated via Standards Action <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS Alert Registry: Future values are allocated via Standards Action <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS HandshakeType Registry: Future values are allocated via Standards Action <a href="#RFC2434">[RFC2434]</a>.</li>
</ul>
<p id="rfc.section.11.p.3">This document also uses a registry originally created in <a href="#RFC4366">[RFC4366]</a>. IANA has updated it to reference this document. The registry and its allocation policy is listed below:</p>
<p/>

<ul>
  <li>TLS ExtensionType Registry: Values with the first byte in the range 0-254 (decimal) are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values with the first byte 255 (decimal) are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>. IANA [SHALL update/has updated] this registry to include the &#8220;key_share&#8221;, &#8220;pre_shared_key&#8221;, and &#8220;early_data&#8221; extensions as defined in this document.  <br/><br/> IANA [shall update/has updated] this registry to include a &#8220;TLS 1.3&#8221; column with the following four values: &#8220;Client&#8221;, indicating that the server shall not send them. &#8220;Clear&#8221;, indicating that they shall be in the ServerHello. &#8220;Encrypted&#8221;, indicating that they shall be in the EncryptedExtensions block, &#8220;Early&#8221;, indicating that they shall be only in the client&#8217;s 0-RTT EncryptedExtensions block, and &#8220;No&#8221; indicating that they are not used in TLS 1.3. This column [shall be/has been] initially populated with the values in this document.  IANA [shall update/has updated] this registry to add a &#8220;Recommended&#8221; column. IANA [shall/has] initially populated this column with the values in the table below. This table has been generated by marking Standards Track RFCs as &#8220;Yes&#8221; and all others as &#8220;No&#8221;.</li>
</ul>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Extension</th>
      <th class="right">Recommended</th>
      <th class="right">TLS 1.3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">server_name <a href="#RFC6066">[RFC6066]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">max_fragment_length <a href="#RFC6066">[RFC6066]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">client_certificate_url <a href="#RFC6066">[RFC6066]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">trusted_ca_keys <a href="#RFC6066">[RFC6066]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">truncated_hmac <a href="#RFC6066">[RFC6066]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">status_request <a href="#RFC6066">[RFC6066]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">user_mapping <a href="#RFC4681">[RFC4681]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">client_authz <a href="#RFC5878">[RFC5878]</a></td>
      <td class="right">No</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">server_authz <a href="#RFC5878">[RFC5878]</a></td>
      <td class="right">No</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">cert_type <a href="#RFC6091">[RFC6091]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">supported_groups [RFC-ietf-tls-negotiated-ff-dhe]</td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">ec_point_formats <a href="#RFC4492">[RFC4492]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">srp <a href="#RFC5054">[RFC5054]</a></td>
      <td class="right">No</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">signature_algorithms <a href="#RFC5246">[RFC5246]</a></td>
      <td class="right">Yes</td>
      <td class="right">Client</td>
    </tr>
    <tr>
      <td class="left">use_srtp <a href="#RFC5764">[RFC5764]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">heartbeat <a href="#RFC6520">[RFC6520]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">application_layer_protocol_negotiation <a href="#RFC7301">[RFC7301]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">status_request_v2 <a href="#RFC6961">[RFC6961]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">signed_certificate_timestamp <a href="#RFC6962">[RFC6962]</a></td>
      <td class="right">No</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">client_certificate_type <a href="#RFC7250">[RFC7250]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">server_certificate_type <a href="#RFC7250">[RFC7250]</a></td>
      <td class="right">Yes</td>
      <td class="right">Encrypted</td>
    </tr>
    <tr>
      <td class="left">padding <a href="#RFC7685">[RFC7685]</a></td>
      <td class="right">Yes</td>
      <td class="right">Client</td>
    </tr>
    <tr>
      <td class="left">encrypt_then_mac <a href="#RFC7366">[RFC7366]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">extended_master_secret <a href="#RFC7627">[RFC7627]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">SessionTicket TLS <a href="#RFC4507">[RFC4507]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">renegotiation_info <a href="#RFC5746">[RFC5746]</a></td>
      <td class="right">Yes</td>
      <td class="right">No</td>
    </tr>
    <tr>
      <td class="left">key_share [[this document]]</td>
      <td class="right">Yes</td>
      <td class="right">Clear</td>
    </tr>
    <tr>
      <td class="left">pre_shared_key [[this document]]</td>
      <td class="right">Yes</td>
      <td class="right">Clear</td>
    </tr>
    <tr>
      <td class="left">early_data [[this document]]</td>
      <td class="right">Yes</td>
      <td class="right">Clear</td>
    </tr>
    <tr>
      <td class="left">ticket_age [[this document]]</td>
      <td class="right">Yes</td>
      <td class="right">Early</td>
    </tr>
    <tr>
      <td class="left">cookie [[this document]]</td>
      <td class="right">Yes</td>
      <td class="right">Encrypted/HelloRetryRequest</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.11.p.5">In addition, this document defines two new registries to be maintained by IANA</p>
<p/>

<ul>
  <li>TLS SignatureScheme Registry: Values with the first byte in the range 0-254 (decimal) are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values with the first byte 255 (decimal) are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>. This registry SHALL have a &#8220;Recommended&#8221; column.  The registry [shall be/ has been] initially populated with the values described in <a href="#signature-algorithms">Section 6.3.2.2</a>. The following values SHALL be marked as &#8220;Recommended&#8221;: ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, rsa_pss_sha256, rsa_pss_sha384, rsa_pss_sha512, ed25519.</li>
</ul>
<h1 id="rfc.references"><a href="#rfc.references">12.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">12.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="AES">[AES]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology</a>, "<a>Specification for the Advanced Encryption Standard (AES)</a>", NIST FIPS 197, November 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="DH">[DH]</b>
      </td>
      <td class="top"><a>Diffie, W.</a> and <a>M. Hellman</a>, "<a>New Directions in Cryptography</a>", IEEE Transactions on Information Theory, V.IT-22 n.6 , June 1977.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-chacha20-poly1305">[I-D.ietf-tls-chacha20-poly1305]</b>
      </td>
      <td class="top"><a>Langley, A.</a>, <a>Chang, W.</a>, <a>Mavrogiannopoulos, N.</a>, <a>Strombergson, J.</a> and <a>S. Josefsson</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-chacha20-poly1305-04">ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS)</a>", Internet-Draft draft-ietf-tls-chacha20-poly1305-04, December 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.irtf-cfrg-eddsa">[I-D.irtf-cfrg-eddsa]</b>
      </td>
      <td class="top"><a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="http://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05">Edwards-curve Digital Signature Algorithm (EdDSA)</a>", Internet-Draft draft-irtf-cfrg-eddsa-05, March 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.mattsson-tls-ecdhe-psk-aead">[I-D.mattsson-tls-ecdhe-psk-aead]</b>
      </td>
      <td class="top"><a>Mattsson, J.</a> and <a>D. Migault</a>, "<a href="http://tools.ietf.org/html/draft-mattsson-tls-ecdhe-psk-aead-05">ECDHE_PSK with AES-GCM and AES-CCM Cipher Suites for Transport Layer Security (TLS)</a>", Internet-Draft draft-mattsson-tls-ecdhe-psk-aead-05, April 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2104">[RFC2104]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, "<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2434">[RFC2434]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc2434">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 2434, DOI 10.17487/RFC2434, October 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3447">[RFC3447]</b>
      </td>
      <td class="top"><a>Jonsson, J.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>", RFC 3447, DOI 10.17487/RFC3447, February 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5288">[RFC5288]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Choudhury, A.</a> and <a>D. McGrew</a>, "<a href="http://tools.ietf.org/html/rfc5288">AES Galois Counter Mode (GCM) Cipher Suites for TLS</a>", RFC 5288, DOI 10.17487/RFC5288, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5289">[RFC5289]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5289">TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)</a>", RFC 5289, DOI 10.17487/RFC5289, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5487">[RFC5487]</b>
      </td>
      <td class="top"><a>Badra, M.</a>, "<a href="http://tools.ietf.org/html/rfc5487">Pre-Shared Key Cipher Suites for TLS with SHA-256/384 and AES Galois Counter Mode</a>", RFC 5487, DOI 10.17487/RFC5487, March 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, DOI 10.17487/RFC5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5869">[RFC5869]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6066">[RFC6066]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6209">[RFC6209]</b>
      </td>
      <td class="top"><a>Kim, W.</a>, <a>Lee, J.</a>, <a>Park, J.</a> and <a>D. Kwon</a>, "<a href="http://tools.ietf.org/html/rfc6209">Addition of the ARIA Cipher Suites to Transport Layer Security (TLS)</a>", RFC 6209, DOI 10.17487/RFC6209, April 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6367">[RFC6367]</b>
      </td>
      <td class="top"><a>Kanno, S.</a> and <a>M. Kanda</a>, "<a href="http://tools.ietf.org/html/rfc6367">Addition of the Camellia Cipher Suites to Transport Layer Security (TLS)</a>", RFC 6367, DOI 10.17487/RFC6367, September 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6655">[RFC6655]</b>
      </td>
      <td class="top"><a>McGrew, D.</a> and <a>D. Bailey</a>, "<a href="http://tools.ietf.org/html/rfc6655">AES-CCM Cipher Suites for Transport Layer Security (TLS)</a>", RFC 6655, DOI 10.17487/RFC6655, July 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6961">[RFC6961]</b>
      </td>
      <td class="top"><a>Pettersen, Y.</a>, "<a href="http://tools.ietf.org/html/rfc6961">The Transport Layer Security (TLS) Multiple Certificate Status Request Extension</a>", RFC 6961, DOI 10.17487/RFC6961, June 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6962">[RFC6962]</b>
      </td>
      <td class="top"><a>Laurie, B.</a>, <a>Langley, A.</a> and <a>E. Kasper</a>, "<a href="http://tools.ietf.org/html/rfc6962">Certificate Transparency</a>", RFC 6962, DOI 10.17487/RFC6962, June 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7251">[RFC7251]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, <a>Bailey, D.</a>, <a>Campagna, M.</a> and <a>R. Dugal</a>, "<a href="http://tools.ietf.org/html/rfc7251">AES-CCM Elliptic Curve Cryptography (ECC) Cipher Suites for TLS</a>", RFC 7251, DOI 10.17487/RFC7251, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7748">[RFC7748]</b>
      </td>
      <td class="top"><a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="http://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SHS">[SHS]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology, U.S. Department of Commerce</a>, "<a>Secure Hash Standard</a>", NIST FIPS PUB 180-4, March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X690">[X690]</b>
      </td>
      <td class="top"><a>ITU-T</a>, "<a>Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO/IEC 8825-1:2002, 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X962">[X962]</b>
      </td>
      <td class="top"><a>ANSI</a>, "<a>Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", ANSI X9.62, 1998.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">12.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="DSS">[DSS]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology, U.S. Department of Commerce</a>, "<a>Digital Signature Standard, version 4</a>", NIST FIPS PUB 186-4, 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="ECDSA">[ECDSA]</b>
      </td>
      <td class="top"><a>American National Standards Institute</a>, "<a>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", ANSI ANS X9.62-2005, November 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="FI06">[FI06]</b>
      </td>
      <td class="top"><a>Finney, H.</a>, "<a href="https://www.ietf.org/mail-archive/web/openpgp/current/msg00999.html">Bleichenbacher's RSA signature forgery based on implementation error</a>", August 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="GCM">[GCM]</b>
      </td>
      <td class="top"><a>Dworkin, M.</a>, "<a>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</a>", NIST Special Publication 800-38D, November 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-cached-info">[I-D.ietf-tls-cached-info]</b>
      </td>
      <td class="top"><a>Santesson, S.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-cached-info-23">Transport Layer Security (TLS) Cached Information Extension</a>", Internet-Draft draft-ietf-tls-cached-info-23, May 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-negotiated-ff-dhe">[I-D.ietf-tls-negotiated-ff-dhe]</b>
      </td>
      <td class="top"><a>Gillmor, D.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe-10">Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for TLS</a>", Internet-Draft draft-ietf-tls-negotiated-ff-dhe-10, June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="IEEE1363">[IEEE1363]</b>
      </td>
      <td class="top"><a>IEEE</a>, "<a>Standard Specifications for Public Key Cryptography</a>", IEEE 1363 , 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="PKCS6">[PKCS6]</b>
      </td>
      <td class="top"><a>RSA Laboratories</a>, "<a>PKCS #6: RSA Extended Certificate Syntax Standard, version 1.5</a>", November 1993.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="PKCS7">[PKCS7]</b>
      </td>
      <td class="top"><a>RSA Laboratories</a>, "<a>PKCS #7: RSA Cryptographic Message Syntax Standard, version 1.5</a>", November 1993.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="PSK-FINISHED">[PSK-FINISHED]</b>
      </td>
      <td class="top"><a>Cremers, C.</a>, <a>Horvat, M.</a>, <a>van der Merwe, T.</a> and <a>S. Scott</a>, "<a href="https://www.ietf.org/mail-archive/web/tls/current/msg18215.html">Revision 10: possible attack if client authentication is allowed during PSK</a>", 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1948">[RFC1948]</b>
      </td>
      <td class="top"><a>Bellovin, S.</a>, "<a href="http://tools.ietf.org/html/rfc1948">Defending Against Sequence Number Attacks</a>", RFC 1948, DOI 10.17487/RFC1948, May 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4086">[RFC4086]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4279">[RFC4279]</b>
      </td>
      <td class="top"><a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc4279">Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</a>", RFC 4279, DOI 10.17487/RFC4279, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4302">[RFC4302]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>", RFC 4302, DOI 10.17487/RFC4302, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4303">[RFC4303]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, DOI 10.17487/RFC4303, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4346">[RFC4346]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>", RFC 4346, DOI 10.17487/RFC4346, April 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4366">[RFC4366]</b>
      </td>
      <td class="top"><a>Blake-Wilson, S.</a>, <a>Nystrom, M.</a>, <a>Hopwood, D.</a>, <a>Mikkelsen, J.</a> and <a>T. Wright</a>, "<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>", RFC 4366, DOI 10.17487/RFC4366, April 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4492">[RFC4492]</b>
      </td>
      <td class="top"><a>Blake-Wilson, S.</a>, <a>Bolyard, N.</a>, <a>Gupta, V.</a>, <a>Hawk, C.</a> and <a>B. Moeller</a>, "<a href="http://tools.ietf.org/html/rfc4492">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</a>", RFC 4492, DOI 10.17487/RFC4492, May 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4506">[RFC4506]</b>
      </td>
      <td class="top"><a>Eisler, M.</a>, "<a href="http://tools.ietf.org/html/rfc4506">XDR: External Data Representation Standard</a>", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4507">[RFC4507]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Zhou, H.</a>, <a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc4507">Transport Layer Security (TLS) Session Resumption without Server-Side State</a>", RFC 4507, DOI 10.17487/RFC4507, May 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4681">[RFC4681]</b>
      </td>
      <td class="top"><a>Santesson, S.</a>, <a>Medvinsky, A.</a> and <a>J. Ball</a>, "<a href="http://tools.ietf.org/html/rfc4681">TLS User Mapping Extension</a>", RFC 4681, DOI 10.17487/RFC4681, October 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5054">[RFC5054]</b>
      </td>
      <td class="top"><a>Taylor, D.</a>, <a>Wu, T.</a>, <a>Mavrogiannopoulos, N.</a> and <a>T. Perrin</a>, "<a href="http://tools.ietf.org/html/rfc5054">Using the Secure Remote Password (SRP) Protocol for TLS Authentication</a>", RFC 5054, DOI 10.17487/RFC5054, November 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5077">[RFC5077]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Zhou, H.</a>, <a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc5077">Transport Layer Security (TLS) Session Resumption without Server-Side State</a>", RFC 5077, DOI 10.17487/RFC5077, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5081">[RFC5081]</b>
      </td>
      <td class="top"><a>Mavrogiannopoulos, N.</a>, "<a href="http://tools.ietf.org/html/rfc5081">Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</a>", RFC 5081, DOI 10.17487/RFC5081, November 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5746">[RFC5746]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, <a>Ray, M.</a>, <a>Dispensa, S.</a> and <a>N. Oskov</a>, "<a href="http://tools.ietf.org/html/rfc5746">Transport Layer Security (TLS) Renegotiation Indication Extension</a>", RFC 5746, DOI 10.17487/RFC5746, February 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5763">[RFC5763]</b>
      </td>
      <td class="top"><a>Fischl, J.</a>, <a>Tschofenig, H.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5763">Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)</a>", RFC 5763, DOI 10.17487/RFC5763, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5764">[RFC5764]</b>
      </td>
      <td class="top"><a>McGrew, D.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5764">Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</a>", RFC 5764, DOI 10.17487/RFC5764, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5878">[RFC5878]</b>
      </td>
      <td class="top"><a>Brown, M.</a> and <a>R. Housley</a>, "<a href="http://tools.ietf.org/html/rfc5878">Transport Layer Security (TLS) Authorization Extensions</a>", RFC 5878, DOI 10.17487/RFC5878, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5929">[RFC5929]</b>
      </td>
      <td class="top"><a>Altman, J.</a>, <a>Williams, N.</a> and <a>L. Zhu</a>, "<a href="http://tools.ietf.org/html/rfc5929">Channel Bindings for TLS</a>", RFC 5929, DOI 10.17487/RFC5929, July 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6091">[RFC6091]</b>
      </td>
      <td class="top"><a>Mavrogiannopoulos, N.</a> and <a>D. Gillmor</a>, "<a href="http://tools.ietf.org/html/rfc6091">Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</a>", RFC 6091, DOI 10.17487/RFC6091, February 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6176">[RFC6176]</b>
      </td>
      <td class="top"><a>Turner, S.</a> and <a>T. Polk</a>, "<a href="http://tools.ietf.org/html/rfc6176">Prohibiting Secure Sockets Layer (SSL) Version 2.0</a>", RFC 6176, DOI 10.17487/RFC6176, March 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6520">[RFC6520]</b>
      </td>
      <td class="top"><a>Seggelmann, R.</a>, <a>Tuexen, M.</a> and <a>M. Williams</a>, "<a href="http://tools.ietf.org/html/rfc6520">Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension</a>", RFC 6520, DOI 10.17487/RFC6520, February 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7250">[RFC7250]</b>
      </td>
      <td class="top"><a>Wouters, P.</a>, <a>Tschofenig, H.</a>, <a>Gilmore, J.</a>, <a>Weiler, S.</a> and <a>T. Kivinen</a>, "<a href="http://tools.ietf.org/html/rfc7250">Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", RFC 7250, DOI 10.17487/RFC7250, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7301">[RFC7301]</b>
      </td>
      <td class="top"><a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="http://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7366">[RFC7366]</b>
      </td>
      <td class="top"><a>Gutmann, P.</a>, "<a href="http://tools.ietf.org/html/rfc7366">Encrypt-then-MAC for Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", RFC 7366, DOI 10.17487/RFC7366, September 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7465">[RFC7465]</b>
      </td>
      <td class="top"><a>Popov, A.</a>, "<a href="http://tools.ietf.org/html/rfc7465">Prohibiting RC4 Cipher Suites</a>", RFC 7465, DOI 10.17487/RFC7465, February 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7568">[RFC7568]</b>
      </td>
      <td class="top"><a>Barnes, R.</a>, <a>Thomson, M.</a>, <a>Pironti, A.</a> and <a>A. Langley</a>, "<a href="http://tools.ietf.org/html/rfc7568">Deprecating Secure Sockets Layer Version 3.0</a>", RFC 7568, DOI 10.17487/RFC7568, June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7627">[RFC7627]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a>, <a>Delignat-Lavaud, A.</a>, <a>Pironti, A.</a>, <a>Langley, A.</a> and <a>M. Ray</a>, "<a href="http://tools.ietf.org/html/rfc7627">Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</a>", RFC 7627, DOI 10.17487/RFC7627, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7685">[RFC7685]</b>
      </td>
      <td class="top"><a>Langley, A.</a>, "<a href="http://tools.ietf.org/html/rfc7685">A Transport Layer Security (TLS) ClientHello Padding Extension</a>", RFC 7685, DOI 10.17487/RFC7685, October 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RSA">[RSA]</b>
      </td>
      <td class="top"><a>Rivest, R.</a>, <a>Shamir, A.</a> and <a>L. Adleman</a>, "<a>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</a>", Communications of the ACM v. 21, n. 2, pp. 120-126., February 1978.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SLOTH">[SLOTH]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a> and <a>G. Leurent</a>, "<a>Transcript Collision Attacks: Breaking Authentication in TLS, IKE, and SSH</a>", Network and Distributed System Security Symposium (NDSS 2016) , 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SSL2">[SSL2]</b>
      </td>
      <td class="top"><a title="Netscape Communications Corp.">Hickman, K.</a>, "<a>The SSL Protocol</a>", February 1995.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SSL3">[SSL3]</b>
      </td>
      <td class="top"><a title="Netscape Communications Corp.">Freier, A.</a>, <a title="Netscape Communications Corp.">Karlton, P.</a> and <a title="Netscape Communications Corp.">P. Kocher</a>, "<a>The SSL 3.0 Protocol</a>", November 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TIMING">[TIMING]</b>
      </td>
      <td class="top"><a>Boneh, D.</a> and <a>D. Brumley</a>, <a>Remote timing attacks are practical</a>", USENIX Security Symposium, 2003.</td>
    </tr>
    <tr><td class="reference"><b id="X501">[X501]</b></td><td class="top"><a>Information Technology - Open Systems Interconnection - The Directory: Models</a>", ITU-T X.501, 1993.</td>, "</tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#protocol-data-structures-and-constant-values" id="protocol-data-structures-and-constant-values">Protocol Data Structures and Constant Values</a></h1>
<p id="rfc.section.A.p.1">This section describes protocol types and constants. Values listed as _RESERVED were used in previous versions of TLS and are listed here for completeness. TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.</p>
<h2 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> <a href="#record-layer-1" id="record-layer-1">Record Layer</a></h2>
<pre>
   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   enum {
       invalid_RESERVED(0),
       change_cipher_spec_RESERVED(20),
       alert(21),
       handshake(22),
       application_data(23)
       (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion record_version = { 3, 1 };    /* TLS v1.x */
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType opaque_type = application_data(23); /* see fragment.type */
       ProtocolVersion record_version = { 3, 1 };    /* TLS v1.x */
       uint16 length;
       aead-ciphered struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
       } fragment;
   } TLSCiphertext;
</pre>
<h2 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> <a href="#alert-messages" id="alert-messages">Alert Messages</a></h2>
<pre>
   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       end_of_early_data(1),
       unexpected_message(10),               /* fatal */
       bad_record_mac(20),                   /* fatal */
       decryption_failed_RESERVED(21),       /* fatal */
       record_overflow(22),                  /* fatal */
       decompression_failure_RESERVED(30),   /* fatal */
       handshake_failure(40),                /* fatal */
       no_certificate_RESERVED(41),          /* fatal */
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),                /* fatal */
       unknown_ca(48),                       /* fatal */
       access_denied(49),                    /* fatal */
       decode_error(50),                     /* fatal */
       decrypt_error(51),                    /* fatal */
       export_restriction_RESERVED(60),      /* fatal */
       protocol_version(70),                 /* fatal */
       insufficient_security(71),            /* fatal */
       internal_error(80),                   /* fatal */
       inappropriate_fallback(86),           /* fatal */
       user_canceled(90),
       no_renegotiation_RESERVED(100),       /* fatal */
       missing_extension(109),               /* fatal */
       unsupported_extension(110),           /* fatal */
       certificate_unobtainable(111),
       unrecognized_name(112),
       bad_certificate_status_response(113), /* fatal */
       bad_certificate_hash_value(114),      /* fatal */
       unknown_psk_identity(115),
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
</pre>
<h2 id="rfc.appendix.A.3"><a href="#rfc.appendix.A.3">A.3.</a> <a href="#handshake-protocol-1" id="handshake-protocol-1">Handshake Protocol</a></h2>
<pre>
   enum {
       hello_request_RESERVED(0),
       client_hello(1),
       server_hello(2),
       session_ticket(4),
       hello_retry_request(6),
       encrypted_extensions(8),
       certificate(11),
       server_key_exchange_RESERVED(12),
       certificate_request(13),
       server_hello_done_RESERVED(14),
       certificate_verify(15),
       client_key_exchange_RESERVED(16),
       finished(20),
       key_update(24),
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (HandshakeType) {
           case client_hello:          ClientHello;
           case server_hello:          ServerHello;
           case hello_retry_request:   HelloRetryRequest;
           case encrypted_extensions:  EncryptedExtensions;
           case certificate_request:   CertificateRequest;
           case certificate:           Certificate;
           case certificate_verify:    CertificateVerify;
           case finished:              Finished;
           case session_ticket:        NewSessionTicket;
           case key_update:            KeyUpdate;
       } body;
   } Handshake;
</pre>
<h3 id="rfc.appendix.A.3.1"><a href="#rfc.appendix.A.3.1">A.3.1.</a> <a href="#key-exchange-messages-1" id="key-exchange-messages-1">Key Exchange Messages</a></h3>
<pre>
   struct {
       opaque random_bytes[32];
   } Random;

   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   struct {
       ProtocolVersion client_version = { 3, 4 };    /* TLS v1.3 */
       Random random;
       opaque legacy_session_id&lt;0..32&gt;;
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       opaque legacy_compression_methods&lt;1..2^8-1&gt;;
       Extension extensions&lt;0..2^16-1&gt;;
   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       CipherSuite cipher_suite;
       Extension extensions&lt;0..2^16-1&gt;;
   } ServerHello;

   struct {
       ProtocolVersion server_version;
       CipherSuite cipher_suite;
       NamedGroup selected_group;
       Extension extensions&lt;0..2^16-1&gt;;
   } HelloRetryRequest;

   struct {
       ExtensionType extension_type;
       opaque extension_data&lt;0..2^16-1&gt;;
   } Extension;

   enum {
       supported_groups(10),
       signature_algorithms(13),
       key_share(40),
       pre_shared_key(41),
       early_data(42),
       ticket_age(43),
       cookie (44),
       (65535)
   } ExtensionType;

   struct {
       NamedGroup group;
       opaque key_exchange&lt;1..2^16-1&gt;;
   } KeyShareEntry;

   struct {
       select (role) {
           case client:
               KeyShareEntry client_shares&lt;0..2^16-1&gt;;

           case server:
               KeyShareEntry server_share;
       }
   } KeyShare;

   opaque psk_identity&lt;0..2^16-1&gt;;

   struct {
       select (Role) {
           case client:
               psk_identity identities&lt;2..2^16-1&gt;;

           case server:
               uint16 selected_identity;
       }
   } PreSharedKeyExtension;

   struct {
       select (Role) {
           case client:
               opaque context&lt;0..255&gt;;

           case server:
              struct {};
       }
   } EarlyDataIndication;

   struct {
       uint32 ticket_age;
   } TicketAge;
</pre>
<h4 id="rfc.appendix.A.3.1.1"><a href="#rfc.appendix.A.3.1.1">A.3.1.1.</a> <a href="#cookie-extension" id="cookie-extension">Cookie Extension</a></h4>
<pre>
   struct {
       opaque cookie&lt;0..255&gt;;
   } Cookie;
</pre>
<h4 id="rfc.appendix.A.3.1.2"><a href="#rfc.appendix.A.3.1.2">A.3.1.2.</a> <a href="#signature-algorithm-extension" id="signature-algorithm-extension">Signature Algorithm Extension</a></h4>
<pre>
   enum {
       /* RSASSA-PKCS-v1_5 algorithms */
       rsa_pkcs1_sha1 (0x0201),
       rsa_pkcs1_sha256 (0x0401),
       rsa_pkcs1_sha384 (0x0501),
       rsa_pkcs1_sha512 (0x0601),

       /* ECDSA algorithms */
       ecdsa_secp256r1_sha256 (0x0403),
       ecdsa_secp384r1_sha384 (0x0503),
       ecdsa_secp521r1_sha512 (0x0603),

       /* RSASSA-PSS algorithms */
       rsa_pss_sha256 (0x0700),
       rsa_pss_sha384 (0x0701),
       rsa_pss_sha512 (0x0702),

       /* EdDSA algorithms */
       ed25519 (0x0703),
       ed448 (0x0704),

       /* Reserved Code Points */
       dsa_sha1_RESERVED (0x0202),
       dsa_sha256_RESERVED (0x0402),
       dsa_sha384_RESERVED (0x0502),
       dsa_sha512_RESERVED (0x0602),
       obsolete_RESERVED (0x0000..0x0200),
       obsolete_RESERVED (0x0203..0x0400),
       obsolete_RESERVED (0x0404..0x0500),
       obsolete_RESERVED (0x0504..0x0600),
       obsolete_RESERVED (0x0604..0x06FF),
       private_use (0xFE00..0xFFFF),
       (0xFFFF)
   } SignatureScheme;

   SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
</pre>
<h4 id="rfc.appendix.A.3.1.3"><a href="#rfc.appendix.A.3.1.3">A.3.1.3.</a> <a href="#named-group-extension" id="named-group-extension">Named Group Extension</a></h4>
<pre>
   enum {
       /* Elliptic Curve Groups (ECDHE) */
       obsolete_RESERVED (1..22),
       secp256r1 (23), secp384r1 (24), secp521r1 (25),
       obsolete_RESERVED (26..28),
       x25519 (29), x448 (30),

       /* Finite Field Groups (DHE) */
       ffdhe2048 (256), ffdhe3072 (257), ffdhe4096 (258),
       ffdhe6144 (259), ffdhe8192 (260),

       /* Reserved Code Points */
       ffdhe_private_use (0x01FC..0x01FF),
       ecdhe_private_use (0xFE00..0xFEFF),
       obsolete_RESERVED (0xFF01..0xFF02),
       (0xFFFF)
   } NamedGroup;

   struct {
       NamedGroup named_group_list&lt;1..2^16-1&gt;;
   } NamedGroupList;
</pre>
<p id="rfc.section.A.3.1.3.p.1">Values within &#8220;obsolete_RESERVED&#8221; ranges were used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.  The obsolete curves have various known/theoretical weaknesses or have had very little usage, in some cases only due to unintentional server configuration issues. They are no longer considered appropriate for general use and should be assumed to be potentially unsafe. The set of curves specified here is sufficient for interoperability with all currently deployed and properly configured TLS implementations.</p>
<h4 id="rfc.appendix.A.3.1.4"><a href="#rfc.appendix.A.3.1.4">A.3.1.4.</a> <a href="#deprecated-extensions" id="deprecated-extensions">Deprecated Extensions</a></h4>
<p id="rfc.section.A.3.1.4.p.1">The following extensions are no longer applicable to TLS 1.3, although TLS 1.3 clients MAY send them if they are willing to negotiate them with prior versions of TLS. TLS 1.3 servers MUST ignore these extensions if they are negotiating TLS 1.3: truncated_hmac <a href="#RFC6066">[RFC6066]</a>, srp <a href="#RFC5054">[RFC5054]</a>, encrypt_then_mac <a href="#RFC7366">[RFC7366]</a>, extended_master_secret <a href="#RFC7627">[RFC7627]</a>, SessionTicket <a href="#RFC5077">[RFC5077]</a>, and renegotiation_info <a href="#RFC5746">[RFC5746]</a>.</p>
<h3 id="rfc.appendix.A.3.2"><a href="#rfc.appendix.A.3.2">A.3.2.</a> <a href="#server-parameters-messages" id="server-parameters-messages">Server Parameters Messages</a></h3>
<pre>
   struct {
       Extension extensions&lt;0..2^16-1&gt;;
   } EncryptedExtensions;

   opaque DistinguishedName&lt;1..2^16-1&gt;;

   struct {
       opaque certificate_extension_oid&lt;1..2^8-1&gt;;
       opaque certificate_extension_values&lt;0..2^16-1&gt;;
   } CertificateExtension;

   struct {
       opaque certificate_request_context&lt;0..2^8-1&gt;;
       SignatureScheme
         supported_signature_algorithms&lt;2..2^16-2&gt;;
       DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
       CertificateExtension certificate_extensions&lt;0..2^16-1&gt;;
   } CertificateRequest;
</pre>
<h3 id="rfc.appendix.A.3.3"><a href="#rfc.appendix.A.3.3">A.3.3.</a> <a href="#authentication-messages-1" id="authentication-messages-1">Authentication Messages</a></h3>
<pre>
   opaque ASN1Cert&lt;1..2^24-1&gt;;

   struct {
       opaque certificate_request_context&lt;0..2^8-1&gt;;
       ASN1Cert certificate_list&lt;0..2^24-1&gt;;
   } Certificate;

   struct {
        digitally-signed struct {
           opaque hashed_data[hash_length];
        };
   } CertificateVerify;

   struct {
       opaque verify_data[verify_data_length];
   } Finished;
</pre>
<h3 id="rfc.appendix.A.3.4"><a href="#rfc.appendix.A.3.4">A.3.4.</a> <a href="#ticket-establishment" id="ticket-establishment">Ticket Establishment</a></h3>
<pre>
 enum { (65535) } TicketExtensionType;

 struct {
     TicketExtensionType extension_type;
     opaque extension_data&lt;0..2^16-1&gt;;
 } TicketExtension;

 enum {
   allow_early_data(1)
   allow_dhe_resumption(2),
   allow_psk_resumption(4)
 } TicketFlags;
 
 struct {
     uint32 ticket_lifetime;
     uint32 flags;
     TicketExtension extensions&lt;2..2^16-2&gt;;
     opaque ticket&lt;0..2^16-1&gt;;
 } NewSessionTicket;
</pre>
<h2 id="rfc.appendix.A.4"><a href="#rfc.appendix.A.4">A.4.</a> <a href="#cipher-suites" id="cipher-suites">Cipher Suites</a></h2>
<p id="rfc.section.A.4.p.1">A cipher suite defines a cipher specification supported in TLS and negotiated via hello messages in the TLS handshake.  Cipher suite names follow a general naming convention composed of a series of component algorithm names separated by underscores:</p>
<pre>
   CipherSuite TLS_KEA_AUTH_WITH_CIPHER_HASH = VALUE;
</pre>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Component</th>
      <th class="left">Contents</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">TLS</td>
      <td class="left">The string &#8220;TLS&#8221;</td>
    </tr>
    <tr>
      <td class="left">KEA</td>
      <td class="left">The key exchange algorithm (e.g. ECDHE, DHE)</td>
    </tr>
    <tr>
      <td class="left">AUTH</td>
      <td class="left">The authentication algorithm (e.g. certificates, PSK)</td>
    </tr>
    <tr>
      <td class="left">WITH</td>
      <td class="left">The string &#8220;WITH&#8221;</td>
    </tr>
    <tr>
      <td class="left">CIPHER</td>
      <td class="left">The symmetric cipher used for record protection</td>
    </tr>
    <tr>
      <td class="left">HASH</td>
      <td class="left">The hash algorithm used with HKDF</td>
    </tr>
    <tr>
      <td class="left">VALUE</td>
      <td class="left">The two byte ID assigned for this cipher suite</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.A.4.p.2">The &#8220;CIPHER&#8221; component commonly has sub-components used to designate the cipher name, bits, and mode, if applicable. For example, &#8220;AES_256_GCM&#8221; represents 256-bit AES in the GCM mode of operation. Cipher suite names that lack a &#8220;HASH&#8221; value that are defined for use with TLS 1.2 or later use the SHA-256 hash algorithm by default.</p>
<p id="rfc.section.A.4.p.3">The primary key exchange algorithm used in TLS is Ephemeral Diffie-Hellman <a href="#DH">[DH]</a>. The finite field based version is denoted &#8220;DHE&#8221; and the elliptic curve based version is denoted &#8220;ECDHE&#8221;. Prior versions of TLS supported non-ephemeral key exchanges, however these are not supported by TLS 1.3.</p>
<p id="rfc.section.A.4.p.4">See the definitions of each cipher suite in its specification document for the full details of each combination of algorithms that is specified.</p>
<p id="rfc.section.A.4.p.5">The following is a list of standards track server-authenticated (and optionally client-authenticated) cipher suites which are currently available in TLS 1.3:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Cipher Suite Name</th>
      <th class="left">Value</th>
      <th class="left">Specification</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</td>
      <td class="left">{0x00,0x9E}</td>
      <td class="left">
        <a href="#RFC5288">[RFC5288]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</td>
      <td class="left">{0x00,0x9F}</td>
      <td class="left">
        <a href="#RFC5288">[RFC5288]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</td>
      <td class="left">{0xC0,0x2B}</td>
      <td class="left">
        <a href="#RFC5289">[RFC5289]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</td>
      <td class="left">{0xC0,0x2C}</td>
      <td class="left">
        <a href="#RFC5289">[RFC5289]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td>
      <td class="left">{0xC0,0x2F}</td>
      <td class="left">
        <a href="#RFC5289">[RFC5289]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</td>
      <td class="left">{0xC0,0x30}</td>
      <td class="left">
        <a href="#RFC5289">[RFC5289]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_AES_128_CCM</td>
      <td class="left">{0xC0,0x9E}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_AES_256_CCM</td>
      <td class="left">{0xC0,0x9F}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_AES_128_CCM_8</td>
      <td class="left">{0xC0,0xA2}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_AES_256_CCM_8</td>
      <td class="left">{0xC0,0xA3}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td>
      <td class="left">{0xCC,0xA8}</td>
      <td class="left">
        <a href="#I-D.ietf-tls-chacha20-poly1305">[I-D.ietf-tls-chacha20-poly1305]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</td>
      <td class="left">{0xCC,0xA9}</td>
      <td class="left">
        <a href="#I-D.ietf-tls-chacha20-poly1305">[I-D.ietf-tls-chacha20-poly1305]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td>
      <td class="left">{0xCC,0xAA}</td>
      <td class="left">
        <a href="#I-D.ietf-tls-chacha20-poly1305">[I-D.ietf-tls-chacha20-poly1305]</a>
      </td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.A.4.p.6">Note: The values listed for ChaCha/Poly are preliminary but are being or will be used for interop testing and therefore are likely to be assigned.</p>
<p id="rfc.section.A.4.p.7">Note: ECDHE AES GCM was not yet standards track prior to the publication of this specification. This document promotes the above-listed ciphers to standards track.</p>
<p id="rfc.section.A.4.p.8">The following is a list of standards track ephemeral pre-shared key cipher suites which are currently available in TLS 1.3:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Cipher Suite Name</th>
      <th class="left">Value</th>
      <th class="left">Specification</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">TLS_DHE_PSK_WITH_AES_128_GCM_SHA256</td>
      <td class="left">{0x00,0xAA}</td>
      <td class="left">
        <a href="#RFC5487">[RFC5487]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_PSK_WITH_AES_256_GCM_SHA384</td>
      <td class="left">{0x00,0xAB}</td>
      <td class="left">
        <a href="#RFC5487">[RFC5487]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_PSK_WITH_AES_128_CCM</td>
      <td class="left">{0xC0,0xA6}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_PSK_WITH_AES_256_CCM</td>
      <td class="left">{0xC0,0xA7}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_PSK_DHE_WITH_AES_128_CCM_8</td>
      <td class="left">{0xC0,0xAA}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_PSK_DHE_WITH_AES_256_CCM_8</td>
      <td class="left">{0xC0,0xAB}</td>
      <td class="left">
        <a href="#RFC6655">[RFC6655]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256</td>
      <td class="left">{0xD0,0x01}</td>
      <td class="left">
        <a href="#I-D.mattsson-tls-ecdhe-psk-aead">[I-D.mattsson-tls-ecdhe-psk-aead]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384</td>
      <td class="left">{0xD0,0x02}</td>
      <td class="left">
        <a href="#I-D.mattsson-tls-ecdhe-psk-aead">[I-D.mattsson-tls-ecdhe-psk-aead]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256</td>
      <td class="left">{0xD0,0x03}</td>
      <td class="left">
        <a href="#I-D.mattsson-tls-ecdhe-psk-aead">[I-D.mattsson-tls-ecdhe-psk-aead]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256</td>
      <td class="left">{0xD0,0x04}</td>
      <td class="left">
        <a href="#I-D.mattsson-tls-ecdhe-psk-aead">[I-D.mattsson-tls-ecdhe-psk-aead]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_PSK_WITH_AES_256_CCM_SHA384</td>
      <td class="left">{0xD0,0x05}</td>
      <td class="left">
        <a href="#I-D.mattsson-tls-ecdhe-psk-aead">[I-D.mattsson-tls-ecdhe-psk-aead]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256</td>
      <td class="left">{0xCC,0xAC}</td>
      <td class="left">
        <a href="#I-D.ietf-tls-chacha20-poly1305">[I-D.ietf-tls-chacha20-poly1305]</a>
      </td>
    </tr>
    <tr>
      <td class="left">TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256</td>
      <td class="left">{0xCC,0xAD}</td>
      <td class="left">
        <a href="#I-D.ietf-tls-chacha20-poly1305">[I-D.ietf-tls-chacha20-poly1305]</a>
      </td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.A.4.p.9">Note: The values listed for ECDHE and ChaCha/Poly are preliminary but are being or will be used for interop testing and therefore are likely to be assigned.</p>
<p id="rfc.section.A.4.p.10">Note: <a href="#RFC6655">[RFC6655]</a> is inconsistent with respect to the ordering of components within PSK AES CCM cipher suite names. The names above are as defined.</p>
<p id="rfc.section.A.4.p.11">All cipher suites in this section are specified for use with both TLS 1.2 and TLS 1.3, as well as the corresponding versions of DTLS.  (see <a href="#backward-compatibility">Appendix C</a>)</p>
<p id="rfc.section.A.4.p.12">New cipher suite values are assigned by IANA as described in <a href="#iana-considerations">Section 11</a>.</p>
<h3 id="rfc.appendix.A.4.1"><a href="#rfc.appendix.A.4.1">A.4.1.</a> <a href="#unauthenticated-operation" id="unauthenticated-operation">Unauthenticated Operation</a></h3>
<p id="rfc.section.A.4.1.p.1">Previous versions of TLS offered explicitly unauthenticated cipher suites based on anonymous Diffie-Hellman. These cipher suites have been deprecated in TLS 1.3. However, it is still possible to negotiate cipher suites that do not provide verifiable server authentication by several methods, including:</p>
<p/>

<ul>
  <li>Raw public keys <a href="#RFC7250">[RFC7250]</a>.</li>
  <li>Using a public key contained in a certificate but without validation of the certificate chain or any of its contents.</li>
</ul>
<p id="rfc.section.A.4.1.p.3">Either technique used alone is are vulnerable to man-in-the-middle attacks and therefore unsafe for general use. However, it is also possible to bind such connections to an external authentication mechanism via out-of-band validation of the server&#8217;s public key, trust on first use, or channel bindings <a href="#RFC5929">[RFC5929]</a>. [[NOTE: TLS 1.3 needs a new channel binding definition that has not yet been defined.]] If no such mechanism is used, then the connection has no protection against active man-in-the-middle attack; applications MUST NOT use TLS in such a way absent explicit configuration or a specific application profile.</p>
<h2 id="rfc.appendix.A.5"><a href="#rfc.appendix.A.5">A.5.</a> <a href="#the-security-parameters" id="the-security-parameters">The Security Parameters</a></h2>
<p id="rfc.section.A.5.p.1">These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS record layer in order to initialize a connection state. SecurityParameters includes:</p>
<pre>
   enum { server, client } ConnectionEnd;

   enum { tls_kdf_sha256, tls_kdf_sha384 } KDFAlgorithm;

   enum { aes_gcm } RecordProtAlgorithm;

   /* The algorithms specified in KDFAlgorithm and
      RecordProtAlgorithm may be added to. */

   struct {
       ConnectionEnd          entity;
       KDFAlgorithm           kdf_algorithm;
       RecordProtAlgorithm    record_prot_algorithm;
       uint8                  enc_key_length;
       uint8                  iv_length;
       opaque                 hs_master_secret[48];
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;
</pre>
<h2 id="rfc.appendix.A.6"><a href="#rfc.appendix.A.6">A.6.</a> <a href="#changes-to-rfc-4492" id="changes-to-rfc-4492">Changes to RFC 4492</a></h2>
<p id="rfc.section.A.6.p.1">RFC 4492 <a href="#RFC4492">[RFC4492]</a> adds Elliptic Curve cipher suites to TLS. This document changes some of the structures used in that document. This section details the required changes for implementors of both RFC 4492 and TLS 1.2. Implementors of TLS 1.2 who are not implementing RFC 4492 do not need to read this section.</p>
<p id="rfc.section.A.6.p.2">This document adds an &#8220;algorithm&#8221; field to the digitally-signed element in order to identify the signature and digest algorithms used to create a signature. This change applies to digital signatures formed using ECDSA as well, thus allowing ECDSA signatures to be used with digest algorithms other than SHA-1, provided such use is compatible with the certificate and any restrictions imposed by future revisions of <a href="#RFC5280">[RFC5280]</a>.</p>
<p id="rfc.section.A.6.p.3">As described in <a href="#server-certificate-selection">Section 6.3.4.1.1</a>, the restrictions on the signature algorithms used to sign certificates are no longer tied to the cipher suite.  Thus, the restrictions on the algorithm used to sign certificates specified in Sections 2 and 3 of RFC 4492 are also relaxed. As in this document, the restrictions on the keys in the end-entity certificate remain.</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#implementation-notes" id="implementation-notes">Implementation Notes</a></h1>
<p id="rfc.section.B.p.1">The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.</p>
<h2 id="rfc.appendix.B.1"><a href="#rfc.appendix.B.1">B.1.</a> <a href="#random-number-generation-and-seeding" id="random-number-generation-and-seeding">Random Number Generation and Seeding</a></h2>
<p id="rfc.section.B.1.p.1">TLS requires a cryptographically secure pseudorandom number generator (PRNG).  Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably SHA-256, are acceptable, but cannot provide more security than the size of the random number generator state.</p>
<p id="rfc.section.B.1.p.2">To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more.  Seeding a 128-bit PRNG would thus require approximately 100 such timer values.</p>
<p><a href="#RFC4086">[RFC4086]</a> provides guidance on the generation of random values.</p>
<h2 id="rfc.appendix.B.2"><a href="#rfc.appendix.B.2">B.2.</a> <a href="#certificates-and-authentication" id="certificates-and-authentication">Certificates and Authentication</a></h2>
<p id="rfc.section.B.2.p.1">Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully.  Users should be able to view information about the certificate and root CA.</p>
<h2 id="rfc.appendix.B.3"><a href="#rfc.appendix.B.3">B.3.</a> <a href="#cipher-suite-support" id="cipher-suite-support">Cipher Suite Support</a></h2>
<p id="rfc.section.B.3.p.1">TLS supports a range of key sizes and security levels, including some that provide no or minimal security. A proper implementation will probably not support many cipher suites. Applications SHOULD also enforce minimum and maximum key sizes. For example, certification paths containing keys or signatures weaker than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure applications.  See also <a href="#backwards-compatibility-security-restrictions">Appendix C.4</a>.</p>
<h2 id="rfc.appendix.B.4"><a href="#rfc.appendix.B.4">B.4.</a> <a href="#implementation-pitfalls" id="implementation-pitfalls">Implementation Pitfalls</a></h2>
<p id="rfc.section.B.4.p.1">Implementation experience has shown that certain parts of earlier TLS specifications are not easy to understand, and have been a source of interoperability and security problems. Many of these areas have been clarified in this document, but this appendix contains a short list of the most important things that require special attention from implementors.</p>
<p id="rfc.section.B.4.p.2">TLS protocol issues:</p>
<p/>

<ul>
  <li>Do you correctly handle handshake messages that are fragmented to multiple TLS records (see <a href="#fragmentation">Section 5.2.1</a>)? Including corner cases like a ClientHello that is split to several small fragments? Do you fragment handshake messages that exceed the maximum fragment size? In particular, the certificate and certificate request handshake messages can be large enough to require fragmentation.</li>
  <li>Do you ignore the TLS record layer version number in all TLS records? (see <a href="#backward-compatibility">Appendix C</a>)</li>
  <li>Have you ensured that all support for SSL, RC4, EXPORT ciphers, and MD5 (via the &#8220;signature_algorithm&#8221; extension) is completely removed from all possible configurations that support TLS 1.3 or later, and that attempts to use these obsolete capabilities fail correctly? (see <a href="#backward-compatibility">Appendix C</a>)</li>
  <li>Do you handle TLS extensions in ClientHello correctly, including unknown extensions or omitting the extensions field completely?</li>
  <li>When the server has requested a client certificate, but no suitable certificate is available, do you correctly send an empty Certificate message, instead of omitting the whole message (see <a href="#client-certificate-selection">Section 6.3.4.1.2</a>)?</li>
  <li>When processing the plaintext fragment produced by AEAD-Decrypt and scanning from the end for the ContentType, do you avoid scanning past the start of the cleartext in the event that the peer has sent a malformed plaintext of all-zeros?</li>
  <li>When processing a ClientHello containing a version of { 3, 5 } or higher, do you respond with the highest common version of TLS rather than requiring an exact match?</li>
  <li>Do you ignore unrecognized cipher suites (see <a href="#client-hello">Section 6.3.1.1</a>), named groups (see <a href="#negotiated-groups">Section 6.3.2.3</a>), and signature algorithms (see <a href="#signature-algorithms">Section 6.3.2.2</a>)?</li>
</ul>
<p id="rfc.section.B.4.p.4">Cryptographic details:</p>
<p/>

<ul>
  <li>What countermeasures do you use to prevent timing attacks against RSA signing operations <a href="#TIMING">[TIMING]</a>?</li>
  <li>When verifying RSA signatures, do you accept both NULL and missing parameters (see <a href="#cryptographic-attributes">Section 4.8</a>)? Do you verify that the RSA padding doesn&#8217;t have additional data after the hash value? <a href="#FI06">[FI06]</a></li>
  <li>When using Diffie-Hellman key exchange, do you correctly preserve leading zero bytes in the negotiated key (see <a href="#diffie-hellman">Section 7.3.1</a>)?</li>
  <li>Does your TLS client check that the Diffie-Hellman parameters sent by the server are acceptable (see <a href="#diffie-hellman-key-exchange-with-authentication">Appendix D.1.1.1</a>)?</li>
  <li>Do you use a strong and, most importantly, properly seeded random number generator (see <a href="#random-number-generation-and-seeding">Appendix B.1</a>) Diffie-Hellman private values, the ECDSA &#8220;k&#8221; parameter, and other security-critical values?</li>
  <li>Do you zero-pad Diffie-Hellman public key values to the group size (see <a href="#ffdhe-param">Section 6.3.2.4.1</a>)?</li>
</ul>
<h2 id="rfc.appendix.B.5"><a href="#rfc.appendix.B.5">B.5.</a> <a href="#client-tracking-prevention" id="client-tracking-prevention">Client Tracking Prevention</a></h2>
<p id="rfc.section.B.5.p.1">Clients SHOULD NOT reuse a session ticket for multiple connections. Reuse of a session ticket allows passive observers to correlate different connections.  Servers that issue session tickets SHOULD offer at least as many session tickets as the number of connections that a client might use; for example, a web browser using HTTP/1.1 <a href="#RFC7230">[RFC7230]</a> might open six connections to a server. Servers SHOULD issue new session tickets with every connection. This ensures that clients are always able to use a new session ticket when creating a new connection.</p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#backward-compatibility" id="backward-compatibility">Backward Compatibility</a></h1>
<p id="rfc.section.C.p.1">The TLS protocol provides a built-in mechanism for version negotiation between endpoints potentially supporting different versions of TLS.</p>
<p id="rfc.section.C.p.2">TLS 1.x and SSL 3.0 use compatible ClientHello messages. Servers can also handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible and the client supports the highest protocol version available in the server.</p>
<p id="rfc.section.C.p.3">Prior versions of TLS used the record layer version number for various purposes. (TLSPlaintext.record_version &amp; TLSCiphertext.record_version) As of TLS 1.3, this field is deprecated and its value MUST be ignored by all implementations. Version negotiation is performed using only the handshake versions.  (ClientHello.client_version &amp; ServerHello.server_version) In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.</p>
<p id="rfc.section.C.p.4">For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions&#8217; handshakes. (see <a href="#server-certificate-selection">Section 6.3.4.1.1</a>)</p>
<p id="rfc.section.C.p.5">TLS 1.2 and prior supported an &#8220;Extended Master Secret&#8221; <a href="#RFC7627">[RFC7627]</a> extension which digested large parts of the handshake transcript into the master secret.  Because TLS 1.3 always hashes in the transcript up to the server CertificateVerify, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.</p>
<h2 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> <a href="#negotiating-with-an-older-server" id="negotiating-with-an-older-server">Negotiating with an older server</a></h2>
<p id="rfc.section.C.1.p.1">A TLS 1.3 client who wishes to negotiate with such older servers will send a normal TLS 1.3 ClientHello containing { 3, 4 } (TLS 1.3) in ClientHello.client_version. If the server does not support this version it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol. A client resuming a session SHOULD initiate the connection using the version that was previously negotiated.</p>
<p id="rfc.section.C.1.p.2">Note that 0-RTT data is not compatible with older servers.  See <a href="#zero-rtt-backwards-compatibility">Appendix C.3</a>.</p>
<p id="rfc.section.C.1.p.3">If the version chosen by the server is not supported by the client (or not acceptable), the client MUST send a &#8220;protocol_version&#8221; alert message and close the connection.</p>
<p id="rfc.section.C.1.p.4">If a TLS server receives a ClientHello containing a version number greater than the highest version supported by the server, it MUST reply according to the highest version supported by the server.</p>
<p id="rfc.section.C.1.p.5">Some legacy server implementations are known to not implement the TLS specification properly and might abort connections upon encountering TLS extensions or versions which it is not aware of. Interoperability with buggy servers is a complex topic beyond the scope of this document.  Multiple connection attempts may be required in order to negotiate a backwards compatible connection, however this practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.</p>
<h2 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> <a href="#negotiating-with-an-older-client" id="negotiating-with-an-older-client">Negotiating with an older client</a></h2>
<p id="rfc.section.C.2.p.1">A TLS server can also receive a ClientHello containing a version number smaller than the highest supported version. If the server wishes to negotiate with old clients, it will proceed as appropriate for the highest version supported by the server that is not greater than ClientHello.client_version. For example, if the server supports TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If the server only supports versions greater than client_version, it MUST send a &#8220;protocol_version&#8221; alert message and close the connection.</p>
<p id="rfc.section.C.2.p.2">Note that earlier versions of TLS did not clearly specify the record layer version number value in all cases (TLSPlaintext.record_version). Servers will receive various TLS 1.x versions in this field, however its value MUST always be ignored.</p>
<h2 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> <a href="#zero-rtt-backwards-compatibility" id="zero-rtt-backwards-compatibility">Zero-RTT backwards compatibility</a></h2>
<p id="rfc.section.C.3.p.1">0-RTT data is not compatible with older servers. An older server will respond to the ClientHello with an older ServerHello, but it will not correctly skip the 0-RTT data and fail to complete the handshake. This can cause issues when a client offers 0-RTT, particularly against multi-server deployments. For example, a deployment may deploy TLS 1.3 gradually with some servers implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3 deployment may be downgraded to TLS 1.2.</p>
<p id="rfc.section.C.3.p.2">If a client accepts older versions of TLS and receives an older ServerHello after sending a ClientHello with 0-RTT data, it MAY retry the connection without 0-RTT. It is NOT RECOMMENDED to retry the connection in response to a more generic error or advertise lower versions of TLS.</p>
<p id="rfc.section.C.3.p.3">Multi-server deployments are RECOMMENDED to ensure a stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.</p>
<h2 id="rfc.appendix.C.4"><a href="#rfc.appendix.C.4">C.4.</a> <a href="#backwards-compatibility-security-restrictions" id="backwards-compatibility-security-restrictions">Backwards Compatibility Security Restrictions</a></h2>
<p id="rfc.section.C.4.p.1">If an implementation negotiates use of TLS 1.2, then negotiation of cipher suites also supported by TLS 1.3 SHOULD be preferred, if available.</p>
<p id="rfc.section.C.4.p.2">The security of RC4 cipher suites is considered insufficient for the reasons cited in <a href="#RFC7465">[RFC7465]</a>. Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.</p>
<p id="rfc.section.C.4.p.3">Old versions of TLS permitted the use of very low strength ciphers.  Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.</p>
<p id="rfc.section.C.4.p.4">The security of SSL 2.0 <a href="#SSL2">[SSL2]</a> is considered insufficient for the reasons enumerated in <a href="#RFC6176">[RFC6176]</a>, and MUST NOT be negotiated for any reason.</p>
<p id="rfc.section.C.4.p.5">Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO.  Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.</p>
<p id="rfc.section.C.4.p.6">Implementations MUST NOT send or accept any records with a version less than { 3, 0 }.</p>
<p id="rfc.section.C.4.p.7">The security of SSL 3.0 <a href="#SSL3">[SSL3]</a> is considered insufficient for the reasons enumerated in <a href="#RFC7568">[RFC7568]</a>, and MUST NOT be negotiated for any reason.</p>
<p id="rfc.section.C.4.p.8">Implementations MUST NOT send a ClientHello.client_version or ServerHello.server_version set to { 3, 0 } or less. Any endpoint receiving a Hello message with ClientHello.client_version or ServerHello.server_version set to { 3, 0 } MUST respond with a &#8220;protocol_version&#8221; alert message and close the connection.</p>
<p id="rfc.section.C.4.p.9">Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of <a href="#RFC6066">[RFC6066]</a>, as it is not applicable to AEAD ciphers and has been shown to be insecure in some scenarios.</p>
<h1 id="rfc.appendix.D"><a href="#rfc.appendix.D">Appendix D.</a> <a href="#security-analysis" id="security-analysis">Security Analysis</a></h1>
<p id="rfc.section.D.p.1">[[TODO: The entire security analysis needs a rewrite.]]</p>
<p id="rfc.section.D.p.2">The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.</p>
<h2 id="rfc.appendix.D.1"><a href="#rfc.appendix.D.1">D.1.</a> <a href="#handshake-protocol-2" id="handshake-protocol-2">Handshake Protocol</a></h2>
<p id="rfc.section.D.1.p.1">The TLS Handshake Protocol is responsible for selecting a cipher spec and generating a master secret, which together comprise the primary cryptographic parameters associated with a secure session. The TLS Handshake Protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.</p>
<h3 id="rfc.appendix.D.1.1"><a href="#rfc.appendix.D.1.1">D.1.1.</a> <a href="#authentication-and-key-exchange" id="authentication-and-key-exchange">Authentication and Key Exchange</a></h3>
<p id="rfc.section.D.1.1.p.1">TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other&#8217;s certificate is valid and has not expired or been revoked.</p>
<p id="rfc.section.D.1.1.p.2">[[TODO: Rewrite this because the master_secret is not used this way any more after Hugo&#8217;s changes.]] The general goal of the key exchange process is to create a master_secret known to the communicating parties and not to attackers (see <a href="#key-schedule">Section 7.1</a>). The master_secret is required to generate the Finished messages and record protection keys (see <a href="#finished">Section 6.3.4.3</a> and <a href="#traffic-key-calculation">Section 7.3</a>). By sending a correct Finished message, parties thus prove that they know the correct master_secret.</p>
<h4 id="rfc.appendix.D.1.1.1"><a href="#rfc.appendix.D.1.1.1">D.1.1.1.</a> <a href="#diffie-hellman-key-exchange-with-authentication" id="diffie-hellman-key-exchange-with-authentication">Diffie-Hellman Key Exchange with Authentication</a></h4>
<p id="rfc.section.D.1.1.1.p.1">When Diffie-Hellman key exchange is used, the client and server use the &#8220;key_share&#8221; extension to send temporary Diffie-Hellman parameters. The signature in the certificate verify message (if present) covers the entire handshake up to that point and thus attests the certificate holder&#8217;s desire to use the ephemeral DHE keys.</p>
<p id="rfc.section.D.1.1.1.p.2">Peers SHOULD validate each other&#8217;s public key Y by ensuring that 1 &lt; Y &lt; p-1.  This simple check ensures that the remote peer is properly behaved and isn&#8217;t forcing the local system into a small subgroup.</p>
<p id="rfc.section.D.1.1.1.p.3">Additionally, using a fresh key for each handshake provides Perfect Forward Secrecy. Implementations SHOULD generate a new X for each handshake when using DHE cipher suites.</p>
<h3 id="rfc.appendix.D.1.2"><a href="#rfc.appendix.D.1.2">D.1.2.</a> <a href="#version-rollback-attacks" id="version-rollback-attacks">Version Rollback Attacks</a></h3>
<p id="rfc.section.D.1.2.p.1">Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake. (See also <a href="#backwards-compatibility-security-restrictions">Appendix C.4</a>.)</p>
<p id="rfc.section.D.1.2.p.2">Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute-force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application-specified wait threshold has expired. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.</p>
<h3 id="rfc.appendix.D.1.3"><a href="#rfc.appendix.D.1.3">D.1.3.</a> <a href="#detecting-attacks-against-the-handshake-protocol" id="detecting-attacks-against-the-handshake-protocol">Detecting Attacks Against the Handshake Protocol</a></h3>
<p id="rfc.section.D.1.3.p.1">An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose.</p>
<p id="rfc.section.D.1.3.p.2">For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others&#8217; Finished messages. Without the static secret, the attacker cannot repair the Finished messages, so the attack will be discovered.</p>
<h2 id="rfc.appendix.D.2"><a href="#rfc.appendix.D.2">D.2.</a> <a href="#protecting-application-data" id="protecting-application-data">Protecting Application Data</a></h2>
<p id="rfc.section.D.2.p.1">The shared secrets are hashed with the handshake transcript to produce unique record protection secrets for each connection.</p>
<p id="rfc.section.D.2.p.2">Outgoing data is protected using an AEAD algorithm before transmission. The authentication data includes the sequence number, message type, message length, and the message contents. The message type field is necessary to ensure that messages intended for one TLS record layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64 bits long, they should never overflow.  Messages from one party cannot be inserted into the other&#8217;s output, since they use independent keys.</p>
<h2 id="rfc.appendix.D.3"><a href="#rfc.appendix.D.3">D.3.</a> <a href="#denial-of-service" id="denial-of-service">Denial of Service</a></h2>
<p id="rfc.section.D.3.p.1">TLS is susceptible to a number of denial-of-service (DoS) attacks. In particular, an attacker who initiates a large number of TCP connections can cause a server to consume large amounts of CPU doing asymmetric crypto operations. However, because TLS is generally used over TCP, it is difficult for the attacker to hide their point of origin if proper TCP SYN randomization is used <a href="#RFC1948">[RFC1948]</a> by the TCP stack.</p>
<p id="rfc.section.D.3.p.2">Because TLS runs over TCP, it is also susceptible to a number of DoS attacks on individual connections. In particular, attackers can forge RSTs, thereby terminating connections, or forge partial TLS records, thereby causing the connection to stall. These attacks cannot in general be defended against by a TCP-using protocol. Implementors or users who are concerned with this class of attack should use IPsec AH <a href="#RFC4302">[RFC4302]</a> or ESP <a href="#RFC4303">[RFC4303]</a>.</p>
<h2 id="rfc.appendix.D.4"><a href="#rfc.appendix.D.4">D.4.</a> <a href="#final-notes" id="final-notes">Final Notes</a></h2>
<p id="rfc.section.D.4.p.1">For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.</p>
<p id="rfc.section.D.4.p.2">The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.</p>
<h1 id="rfc.appendix.E"><a href="#rfc.appendix.E">Appendix E.</a> <a href="#working-group-information" id="working-group-information">Working Group Information</a></h1>
<p id="rfc.section.E.p.1">The discussion list for the IETF TLS working group is located at the e-mail address <a href="mailto:tls@ietf.org">tls@ietf.org</a>. Information on the group and information on how to subscribe to the list is at <a href="https://www1.ietf.org/mailman/listinfo/tls">https://www1.ietf.org/mailman/listinfo/tls</a></p>
<p id="rfc.section.E.p.2">Archives of the list can be found at: <a href="https://www.ietf.org/mail-archive/web/tls/current/index.html">https://www.ietf.org/mail-archive/web/tls/current/index.html</a></p>
<h1 id="rfc.appendix.F"><a href="#rfc.appendix.F">Appendix F.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<p/>

<ul>
  <li>Martin Abadi <br/> University of California, Santa Cruz <br/> abadi@cs.ucsc.edu</li>
  <li>Christopher Allen (co-editor of TLS 1.0) <br/> Alacrity Ventures <br/> ChristopherA@AlacrityManagement.com</li>
  <li>Steven M. Bellovin <br/> Columbia University <br/> smb@cs.columbia.edu</li>
  <li>David Benjamin <br/> Google <br/> davidben@google.com</li>
  <li>Benjamin Beurdouche</li>
  <li>Karthikeyan Bhargavan (co-author of <a href="#RFC7627">[RFC7627]</a>) <br/> INRIA <br/> karthikeyan.bhargavan@inria.fr</li>
  <li>Simon Blake-Wilson (co-author of <a href="#RFC4492">[RFC4492]</a>) <br/> BCI <br/> sblakewilson@bcisse.com</li>
  <li>Nelson Bolyard (co-author of <a href="#RFC4492">[RFC4492]</a>) <br/> Sun Microsystems, Inc. <br/> nelson@bolyard.com</li>
  <li>Ran Canetti <br/> IBM <br/> canetti@watson.ibm.com</li>
  <li>Pete Chown <br/> Skygate Technology Ltd <br/> pc@skygate.co.uk</li>
  <li>Antoine Delignat-Lavaud (co-author of <a href="#RFC7627">[RFC7627]</a>) <br/> INRIA <br/> antoine.delignat-lavaud@inria.fr</li>
  <li>Tim Dierks (co-editor of TLS 1.0, 1.1, and 1.2) <br/> Independent <br/> tim@dierks.org</li>
  <li>Taher Elgamal <br/> Securify <br/> taher@securify.com</li>
  <li>Pasi Eronen <br/> Nokia <br/> pasi.eronen@nokia.com</li>
  <li>Cedric Fournet <br/> Microsoft <br/> fournet@microsoft.com</li>
  <li>Anil Gangolli <br/> anil@busybuddha.org</li>
  <li>David M. Garrett</li>
  <li>Vipul Gupta (co-author of <a href="#RFC4492">[RFC4492]</a>) <br/> Sun Microsystems Laboratories <br/> vipul.gupta@sun.com</li>
  <li>Chris Hawk (co-author of <a href="#RFC4492">[RFC4492]</a>) <br/> Corriente Networks LLC <br/> chris@corriente.net</li>
  <li>Kipp Hickman</li>
  <li>Alfred Hoenes</li>
  <li>David Hopwood <br/> Independent Consultant <br/> david.hopwood@blueyonder.co.uk</li>
  <li>Subodh Iyengar <br/> Facebook <br/> subodh@fb.com</li>
  <li>Daniel Kahn Gillmor <br/> ACLU <br/> dkg@fifthhorseman.net</li>
  <li>Phil Karlton (co-author of SSL 3.0)</li>
  <li>Paul Kocher (co-author of SSL 3.0) <br/> Cryptography Research <br/> paul@cryptography.com</li>
  <li>Hugo Krawczyk <br/> IBM <br/> hugo@ee.technion.ac.il</li>
  <li>Adam Langley (co-author of <a href="#RFC7627">[RFC7627]</a>) <br/> Google <br/> agl@google.com</li>
  <li>Ilari Liusvaara <br/> Independent <br/> ilariliusvaara@welho.com</li>
  <li>Jan Mikkelsen <br/> Transactionware <br/> janm@transactionware.com</li>
  <li>Bodo Moeller (co-author of <a href="#RFC4492">[RFC4492]</a>) <br/> Google <br/> bodo@openssl.org</li>
  <li>Erik Nygren <br/> Akamai Technologies <br/> erik+ietf@nygren.org</li>
  <li>Magnus Nystrom <br/> RSA Security <br/> magnus@rsasecurity.com</li>
  <li>Alfredo Pironti (co-author of <a href="#RFC7627">[RFC7627]</a>) <br/> INRIA <br/> alfredo.pironti@inria.fr</li>
  <li>Andrei Popov <br/> Microsoft <br/> andrei.popov@microsoft.com</li>
  <li>Marsh Ray (co-author of <a href="#RFC7627">[RFC7627]</a>) <br/> Microsoft <br/> maray@microsoft.com</li>
  <li>Robert Relyea <br/> Netscape Communications <br/> relyea@netscape.com</li>
  <li>Jim Roskind <br/> Netscape Communications <br/> jar@netscape.com</li>
  <li>Michael Sabin</li>
  <li>Dan Simon <br/> Microsoft, Inc. <br/> dansimon@microsoft.com</li>
  <li>Nick Sullivan <br/> CloudFlare Inc. <br/> nick@cloudflare.com</li>
  <li>Bjoern Tackmann <br/> University of California, San Diego <br/> btackmann@eng.ucsd.edu</li>
  <li>Martin Thomson <br/> Mozilla <br/> mt@mozilla.com</li>
  <li>Tom Weinstein</li>
  <li>Hoeteck Wee <br/> Ecole Normale Superieure, Paris <br/> hoeteck@alum.mit.edu</li>
  <li>Tim Wright <br/> Vodafone <br/> timothy.wright@vodafone.com</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> 
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">RTFM, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/tlswg/tls13-spec">Fork me on GitHub</a></div></div>
</body>
</html>
